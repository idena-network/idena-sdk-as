"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassExporter = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const JSONBuilder_1 = require("./JSONBuilder");
const utils_1 = require("./utils");
const toString = visitor_as_1.utils.toString;
const privateDecorator = 'privateMethod';
class ClassExporter extends visitor_as_1.ClassDecorator {
    sb = [];
    static classSeen;
    static hasConstructor;
    static get className() {
        return toString(ClassExporter.classSeen.name);
    }
    checkMethods(name) {
        let _class = ClassExporter.classSeen;
        _class.members.forEach((member) => {
            if (member instanceof as_1.MethodDeclaration &&
                !member.is(as_1.CommonFlags.PRIVATE)) {
                if (toString(member.name) === name) {
                    throw new Error(`Method "${toString(member.name)}" already used; cannot export constructor using the same name.`);
                }
            }
        });
    }
    visitFieldDeclaration(node) { }
    visitMethodDeclaration(node) {
        if (node.is(as_1.CommonFlags.SET) || node.is(as_1.CommonFlags.GET)) {
            throw new Error('Exported Singleton class cannot have properties. Found ' +
                node.name.text);
        }
        // Private methods should be skipped.
        if (node.is(as_1.CommonFlags.PRIVATE)) {
            return;
        }
        let privateCheck = visitor_as_1.utils.hasDecorator(node, privateDecorator)
            ? `__assertPrivate();`
            : '';
        let name = toString(node.name);
        let decorators = (node.decorators || []).map(toString);
        let returnType = toString(node.signature.returnType);
        let origParams = node.signature.parameters.map(visitor_as_1.utils.cloneNode);
        let parameters = origParams.map((param) => {
            if (param.implicitFieldDeclaration) {
                param.name.text = param.name.text.substring(2);
            }
            return toString(param);
        });
        let pramNames = origParams.map((param) => {
            return toString(param.name);
        });
        let isInit = name === 'constructor';
        let createContractStr = `let __contract: ${ClassExporter.className};
if (__checkState()) {
__contract = __getState<${ClassExporter.className}>();
}${!ClassExporter.hasConstructor
            ? ` else {
__contract = new ${ClassExporter.className}();
}`
            : ''}`;
        let assertStr = '';
        if (isInit) {
            assertStr = `assert(isNull(__contract), "contract is already initialized");`;
        }
        else if (ClassExporter.hasConstructor) {
            assertStr = `assert(!isNull(__contract), "contract is not initialized");`;
        }
        let isVoid = returnType === 'void';
        let body = isInit
            ? `__contract = new ${ClassExporter.className}(${pramNames.join(', ')});`
            : `${!isVoid ? 'let res =  ' : ''}__contract.${name}(${pramNames.join(', ')});`;
        if (isInit) {
            name = '__deploy';
            parameters = origParams.map((node) => `${toString(node.name)}: ${toString(node.type)}${node.initializer ? ' = ' + toString(node.initializer) : ''}`);
            returnType = 'void';
        }
        if (isInit) {
            if (!decorators.some((decorator) => decorator.includes('exportAs'))) {
                decorators.push(`@exportAs("deploy")`);
                this.checkMethods('deploy');
            }
            else {
                let decorator = node.decorators.find((d) => toString(d.name) === 'exportAs');
                if (decorator.args.length == 1) {
                    this.checkMethods(toString(decorator.args[0]));
                }
            }
        }
        const hasMutateState = decorators.some((decorator) => {
            let res = decorator.includes('mutateState');
            return res;
        });
        this.sb.push(`${decorators.join('\n')}
export function ${name}(${parameters.join(', ')}): ${returnType} {
  ${createContractStr}
  ${privateCheck}
  ${assertStr}
  ${body}
  ${isInit || hasMutateState ? `__setState(__contract);` : ''}
  ${isVoid || isInit ? '' : 'return res;'}
}`);
    }
    visitClassDeclaration(node) {
        if ((0, JSONBuilder_1.isEntry)(node) && node.is(as_1.CommonFlags.EXPORT)) {
            let name = toString(node.name);
            if (ClassExporter.classSeen) {
                throw new Error(`Cannot export class ${name}. ${ClassExporter.className} already exported. `);
            }
            ClassExporter.classSeen = node;
            ClassExporter.hasConstructor = node.members.some((member) => {
                if (member instanceof as_1.MethodDeclaration) {
                    return toString(member.name) === 'constructor';
                }
                return false;
            });
            this.visit(node.members);
            this.sb.push(`
        @idenaBindgenIgnore
        export function allocate(size : u32) : usize {
          return __allocate(size);
        }`);
            node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
            let newStatements = utils_1.SimpleParser.parseTopLevel(this.sb.join('\n')).map((n) => {
                if (n instanceof as_1.FunctionDeclaration) {
                    n.flags = n.flags | as_1.CommonFlags.EXPORT;
                    n.flags = n.flags | as_1.CommonFlags.MODULE_EXPORT;
                }
                n.range = node.range;
                return n;
            });
            node.range.source.statements.push(...newStatements);
        }
    }
    get name() {
        return 'idenaBindgen';
    }
    static visit(source) {
        if (source.sourceKind != as_1.SourceKind.USER_ENTRY) {
            return;
        }
        let visitor = new ClassExporter();
        visitor.visit(source);
    }
}
exports.ClassExporter = ClassExporter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NFeHBvcnRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc0V4cG9ydGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQVF1QjtBQUV2QiwyQ0FBaUQ7QUFDakQsK0NBQXNDO0FBQ3RDLG1DQUFxQztBQUVyQyxNQUFNLFFBQVEsR0FBRyxrQkFBSyxDQUFDLFFBQVEsQ0FBQztBQUNoQyxNQUFNLGdCQUFnQixHQUFHLGVBQWUsQ0FBQztBQUV6QyxNQUFhLGFBQWMsU0FBUSwyQkFBYztJQUMvQyxFQUFFLEdBQWEsRUFBRSxDQUFDO0lBQ2xCLE1BQU0sQ0FBQyxTQUFTLENBQW1CO0lBQ25DLE1BQU0sQ0FBQyxjQUFjLENBQVU7SUFFL0IsTUFBTSxLQUFLLFNBQVM7UUFDbEIsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQsWUFBWSxDQUFDLElBQVk7UUFDdkIsSUFBSSxNQUFNLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQztRQUNyQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2hDLElBQ0UsTUFBTSxZQUFZLHNCQUFpQjtnQkFDbkMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLGdCQUFXLENBQUMsT0FBTyxDQUFDLEVBQy9CO2dCQUNBLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQ2IsV0FBVyxRQUFRLENBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQ1osZ0VBQWdFLENBQ2xFLENBQUM7aUJBQ0g7YUFDRjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHFCQUFxQixDQUFDLElBQXNCLElBQVMsQ0FBQztJQUV0RCxzQkFBc0IsQ0FBQyxJQUF1QjtRQUM1QyxJQUFJLElBQUksQ0FBQyxF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QUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsZ0JBQVcsQ0FBQyxNQUFNLENBQUM7WUFDN0MsSUFBSSxhQUFhLEdBQUcsb0JBQVksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQ3BFLENBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQ0osSUFBSSxDQUFDLFlBQVksd0JBQW1CLEVBQUU7b0JBQ3BDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxnQkFBVyxDQUFDLE1BQU0sQ0FBQztvQkFDdkMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLGdCQUFXLENBQUMsYUFBYSxDQUFDO2lCQUMvQztnQkFDRCxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQ3JCLE9BQU8sQ0FBQyxDQUFDO1lBQ1gsQ0FBQyxDQUNGLENBQUM7WUFDRixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsYUFBYSxDQUFDLENBQUM7U0FDckQ7SUFDSCxDQUFDO0lBRUQsSUFBSSxJQUFJO1FBQ04sT0FBTyxjQUFjLENBQUM7SUFDeEIsQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBYztRQUN6QixJQUFJLE1BQU0sQ0FBQyxVQUFVLElBQUksZUFBVSxDQUFDLFVBQVUsRUFBRTtZQUM5QyxPQUFPO1NBQ1I7UUFDRCxJQUFJLE9BQU8sR0FBRyxJQUFJLGFBQWEsRUFBRSxDQUFDO1FBQ2xDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDeEIsQ0FBQztDQUNGO0FBMUtELHNDQTBLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENsYXNzRGVjbGFyYXRpb24sXG4gIEZpZWxkRGVjbGFyYXRpb24sXG4gIE1ldGhvZERlY2xhcmF0aW9uLFxuICBTb3VyY2UsXG4gIENvbW1vbkZsYWdzLFxuICBTb3VyY2VLaW5kLFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uLFxufSBmcm9tICd2aXNpdG9yLWFzL2FzJztcblxuaW1wb3J0IHt1dGlscywgQ2xhc3NEZWNvcmF0b3J9IGZyb20gJ3Zpc2l0b3ItYXMnO1xuaW1wb3J0IHtpc0VudHJ5fSBmcm9tICcuL0pTT05CdWlsZGVyJztcbmltcG9ydCB7U2ltcGxlUGFyc2VyfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgdG9TdHJpbmcgPSB1dGlscy50b1N0cmluZztcbmNvbnN0IHByaXZhdGVEZWNvcmF0b3IgPSAncHJpdmF0ZU1ldGhvZCc7XG5cbmV4cG9ydCBjbGFzcyBDbGFzc0V4cG9ydGVyIGV4dGVuZHMgQ2xhc3NEZWNvcmF0b3Ige1xuICBzYjogc3RyaW5nW10gPSBbXTtcbiAgc3RhdGljIGNsYXNzU2VlbjogQ2xhc3NEZWNsYXJhdGlvbjtcbiAgc3RhdGljIGhhc0NvbnN0cnVjdG9yOiBib29sZWFuO1xuXG4gIHN0YXRpYyBnZXQgY2xhc3NOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKENsYXNzRXhwb3J0ZXIuY2xhc3NTZWVuLm5hbWUpO1xuICB9XG5cbiAgY2hlY2tNZXRob2RzKG5hbWU6IHN0cmluZykge1xuICAgIGxldCBfY2xhc3MgPSBDbGFzc0V4cG9ydGVyLmNsYXNzU2VlbjtcbiAgICBfY2xhc3MubWVtYmVycy5mb3JFYWNoKChtZW1iZXIpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgbWVtYmVyIGluc3RhbmNlb2YgTWV0aG9kRGVjbGFyYXRpb24gJiZcbiAgICAgICAgIW1lbWJlci5pcyhDb21tb25GbGFncy5QUklWQVRFKVxuICAgICAgKSB7XG4gICAgICAgIGlmICh0b1N0cmluZyhtZW1iZXIubmFtZSkgPT09IG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTWV0aG9kIFwiJHt0b1N0cmluZyhcbiAgICAgICAgICAgICAgbWVtYmVyLm5hbWVcbiAgICAgICAgICAgICl9XCIgYWxyZWFkeSB1c2VkOyBjYW5ub3QgZXhwb3J0IGNvbnN0cnVjdG9yIHVzaW5nIHRoZSBzYW1lIG5hbWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZpc2l0RmllbGREZWNsYXJhdGlvbihub2RlOiBGaWVsZERlY2xhcmF0aW9uKTogdm9pZCB7fVxuXG4gIHZpc2l0TWV0aG9kRGVjbGFyYXRpb24obm9kZTogTWV0aG9kRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAobm9kZS5pcyhDb21tb25GbGFncy5TRVQpIHx8IG5vZGUuaXMoQ29tbW9uRmxhZ3MuR0VUKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXhwb3J0ZWQgU2luZ2xldG9uIGNsYXNzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXMuIEZvdW5kICcgK1xuICAgICAgICAgIG5vZGUubmFtZS50ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICAvLyBQcml2YXRlIG1ldGhvZHMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuUFJJVkFURSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByaXZhdGVDaGVjayA9IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBwcml2YXRlRGVjb3JhdG9yKVxuICAgICAgPyBgX19hc3NlcnRQcml2YXRlKCk7YFxuICAgICAgOiAnJztcbiAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKG5vZGUubmFtZSk7XG4gICAgbGV0IGRlY29yYXRvcnMgPSAobm9kZS5kZWNvcmF0b3JzIHx8IFtdKS5tYXAodG9TdHJpbmcpO1xuICAgIGxldCByZXR1cm5UeXBlID0gdG9TdHJpbmcobm9kZS5zaWduYXR1cmUucmV0dXJuVHlwZSk7XG4gICAgbGV0IG9yaWdQYXJhbXMgPSBub2RlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzLm1hcCh1dGlscy5jbG9uZU5vZGUpO1xuICAgIGxldCBwYXJhbWV0ZXJzID0gb3JpZ1BhcmFtcy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICBpZiAocGFyYW0uaW1wbGljaXRGaWVsZERlY2xhcmF0aW9uKSB7XG4gICAgICAgIHBhcmFtLm5hbWUudGV4dCA9IHBhcmFtLm5hbWUudGV4dC5zdWJzdHJpbmcoMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9TdHJpbmcocGFyYW0pO1xuICAgIH0pO1xuICAgIGxldCBwcmFtTmFtZXMgPSBvcmlnUGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwYXJhbS5uYW1lKTtcbiAgICB9KTtcbiAgICBsZXQgaXNJbml0ID0gbmFtZSA9PT0gJ2NvbnN0cnVjdG9yJztcblxuICAgIGxldCBjcmVhdGVDb250cmFjdFN0ciA9IGBsZXQgX19jb250cmFjdDogJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX07XG5pZiAoX19jaGVja1N0YXRlKCkpIHtcbl9fY29udHJhY3QgPSBfX2dldFN0YXRlPCR7Q2xhc3NFeHBvcnRlci5jbGFzc05hbWV9PigpO1xufSR7XG4gICAgICAhQ2xhc3NFeHBvcnRlci5oYXNDb25zdHJ1Y3RvclxuICAgICAgICA/IGAgZWxzZSB7XG5fX2NvbnRyYWN0ID0gbmV3ICR7Q2xhc3NFeHBvcnRlci5jbGFzc05hbWV9KCk7XG59YFxuICAgICAgICA6ICcnXG4gICAgfWA7XG5cbiAgICBsZXQgYXNzZXJ0U3RyOiBzdHJpbmcgPSAnJztcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBhc3NlcnRTdHIgPSBgYXNzZXJ0KGlzTnVsbChfX2NvbnRyYWN0KSwgXCJjb250cmFjdCBpcyBhbHJlYWR5IGluaXRpYWxpemVkXCIpO2A7XG4gICAgfSBlbHNlIGlmIChDbGFzc0V4cG9ydGVyLmhhc0NvbnN0cnVjdG9yKSB7XG4gICAgICBhc3NlcnRTdHIgPSBgYXNzZXJ0KCFpc051bGwoX19jb250cmFjdCksIFwiY29udHJhY3QgaXMgbm90IGluaXRpYWxpemVkXCIpO2A7XG4gICAgfVxuICAgIGxldCBpc1ZvaWQgPSByZXR1cm5UeXBlID09PSAndm9pZCc7XG4gICAgbGV0IGJvZHkgPSBpc0luaXRcbiAgICAgID8gYF9fY29udHJhY3QgPSBuZXcgJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX0oJHtwcmFtTmFtZXMuam9pbignLCAnKX0pO2BcbiAgICAgIDogYCR7IWlzVm9pZCA/ICdsZXQgcmVzID0gICcgOiAnJ31fX2NvbnRyYWN0LiR7bmFtZX0oJHtwcmFtTmFtZXMuam9pbihcbiAgICAgICAgICAnLCAnXG4gICAgICAgICl9KTtgO1xuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIG5hbWUgPSAnX19kZXBsb3knO1xuICAgICAgcGFyYW1ldGVycyA9IG9yaWdQYXJhbXMubWFwKFxuICAgICAgICAobm9kZSkgPT5cbiAgICAgICAgICBgJHt0b1N0cmluZyhub2RlLm5hbWUpfTogJHt0b1N0cmluZyhub2RlLnR5cGUpfSR7XG4gICAgICAgICAgICBub2RlLmluaXRpYWxpemVyID8gJyA9ICcgKyB0b1N0cmluZyhub2RlLmluaXRpYWxpemVyKSA6ICcnXG4gICAgICAgICAgfWBcbiAgICAgICk7XG4gICAgICByZXR1cm5UeXBlID0gJ3ZvaWQnO1xuICAgIH1cbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBpZiAoIWRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IuaW5jbHVkZXMoJ2V4cG9ydEFzJykpKSB7XG4gICAgICAgIGRlY29yYXRvcnMucHVzaChgQGV4cG9ydEFzKFwiZGVwbG95XCIpYCk7XG4gICAgICAgIHRoaXMuY2hlY2tNZXRob2RzKCdkZXBsb3knKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZWNvcmF0b3IgPSBub2RlLmRlY29yYXRvcnMhLmZpbmQoXG4gICAgICAgICAgKGQpID0+IHRvU3RyaW5nKGQubmFtZSkgPT09ICdleHBvcnRBcydcbiAgICAgICAgKSE7XG4gICAgICAgIGlmIChkZWNvcmF0b3IuYXJncyEubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrTWV0aG9kcyh0b1N0cmluZyhkZWNvcmF0b3IuYXJncyFbMF0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYXNNdXRhdGVTdGF0ZSA9IGRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiB7XG4gICAgICBsZXQgcmVzID0gZGVjb3JhdG9yLmluY2x1ZGVzKCdtdXRhdGVTdGF0ZScpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICB0aGlzLnNiLnB1c2goXG4gICAgICBgJHtkZWNvcmF0b3JzLmpvaW4oJ1xcbicpfVxuZXhwb3J0IGZ1bmN0aW9uICR7bmFtZX0oJHtwYXJhbWV0ZXJzLmpvaW4oJywgJyl9KTogJHtyZXR1cm5UeXBlfSB7XG4gICR7Y3JlYXRlQ29udHJhY3RTdHJ9XG4gICR7cHJpdmF0ZUNoZWNrfVxuICAke2Fzc2VydFN0cn1cbiAgJHtib2R5fVxuICAke2lzSW5pdCB8fCBoYXNNdXRhdGVTdGF0ZSA/IGBfX3NldFN0YXRlKF9fY29udHJhY3QpO2AgOiAnJ31cbiAgJHtpc1ZvaWQgfHwgaXNJbml0ID8gJycgOiAncmV0dXJuIHJlczsnfVxufWBcbiAgICApO1xuICB9XG5cbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoaXNFbnRyeShub2RlKSAmJiBub2RlLmlzKENvbW1vbkZsYWdzLkVYUE9SVCkpIHtcbiAgICAgIGxldCBuYW1lID0gdG9TdHJpbmcobm9kZS5uYW1lKTtcbiAgICAgIGlmIChDbGFzc0V4cG9ydGVyLmNsYXNzU2Vlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBleHBvcnQgY2xhc3MgJHtuYW1lfS4gJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX0gYWxyZWFkeSBleHBvcnRlZC4gYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4gPSBub2RlO1xuICAgICAgQ2xhc3NFeHBvcnRlci5oYXNDb25zdHJ1Y3RvciA9IG5vZGUubWVtYmVycy5zb21lKChtZW1iZXIpID0+IHtcbiAgICAgICAgaWYgKG1lbWJlciBpbnN0YW5jZW9mIE1ldGhvZERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKG1lbWJlci5uYW1lKSA9PT0gJ2NvbnN0cnVjdG9yJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTsgICAgICBcbiAgICAgIHRoaXMudmlzaXQobm9kZS5tZW1iZXJzKTtcbiAgICAgIHRoaXMuc2IucHVzaChcbiAgICAgICAgYFxuICAgICAgICBAaWRlbmFCaW5kZ2VuSWdub3JlXG4gICAgICAgIGV4cG9ydCBmdW5jdGlvbiBhbGxvY2F0ZShzaXplIDogdTMyKSA6IHVzaXplIHtcbiAgICAgICAgICByZXR1cm4gX19hbGxvY2F0ZShzaXplKTtcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgICBub2RlLmZsYWdzID0gbm9kZS5mbGFncyBeIENvbW1vbkZsYWdzLkVYUE9SVDtcbiAgICAgIGxldCBuZXdTdGF0ZW1lbnRzID0gU2ltcGxlUGFyc2VyLnBhcnNlVG9wTGV2ZWwodGhpcy5zYi5qb2luKCdcXG4nKSkubWFwKFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgbi5mbGFncyA9IG4uZmxhZ3MgfCBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgICAgICAgICBuLmZsYWdzID0gbi5mbGFncyB8IENvbW1vbkZsYWdzLk1PRFVMRV9FWFBPUlQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4ucmFuZ2UgPSBub2RlLnJhbmdlO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbm9kZS5yYW5nZS5zb3VyY2Uuc3RhdGVtZW50cy5wdXNoKC4uLm5ld1N0YXRlbWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdpZGVuYUJpbmRnZW4nO1xuICB9XG5cbiAgc3RhdGljIHZpc2l0KHNvdXJjZTogU291cmNlKTogdm9pZCB7XG4gICAgaWYgKHNvdXJjZS5zb3VyY2VLaW5kICE9IFNvdXJjZUtpbmQuVVNFUl9FTlRSWSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdmlzaXRvciA9IG5ldyBDbGFzc0V4cG9ydGVyKCk7XG4gICAgdmlzaXRvci52aXNpdChzb3VyY2UpO1xuICB9XG59XG4iXX0=