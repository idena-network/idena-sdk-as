"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassExporter = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const JSONBuilder_1 = require("./JSONBuilder");
const utils_1 = require("./utils");
const toString = visitor_as_1.utils.toString;
const privateDecorator = 'contractPrivate';
class ClassExporter extends visitor_as_1.ClassDecorator {
    sb = [];
    static classSeen;
    static hasConstructor;
    static get className() {
        return toString(ClassExporter.classSeen.name);
    }
    checkMethods(name) {
        let _class = ClassExporter.classSeen;
        _class.members.forEach((member) => {
            if (member instanceof as_1.MethodDeclaration &&
                !member.is(as_1.CommonFlags.PRIVATE)) {
                if (toString(member.name) === name) {
                    throw new Error(`Method "${toString(member.name)}" already used; cannot export constructor using the same name.`);
                }
            }
        });
    }
    visitFieldDeclaration(node) { }
    visitMethodDeclaration(node) {
        if (node.is(as_1.CommonFlags.SET) || node.is(as_1.CommonFlags.GET)) {
            throw new Error('Exported Singleton class cannot have properties. Found ' +
                node.name.text);
        }
        // Private methods should be skipped.
        if (node.is(as_1.CommonFlags.PRIVATE)) {
            return;
        }
        let privateCheck = visitor_as_1.utils.hasDecorator(node, privateDecorator)
            ? `__assertPrivate();`
            : '';
        let name = toString(node.name);
        let decorators = (node.decorators || []).map(toString);
        let returnType = toString(node.signature.returnType);
        let origParams = node.signature.parameters.map(visitor_as_1.utils.cloneNode);
        let parameters = origParams.map((param) => {
            if (param.implicitFieldDeclaration) {
                param.name.text = param.name.text.substring(2);
            }
            return toString(param);
        });
        let pramNames = origParams.map((param) => {
            return toString(param.name);
        });
        let isInit = name === 'constructor';
        let createContractStr = `let __contract: ${ClassExporter.className};
if (__checkState()) {
__contract = __getState<${ClassExporter.className}>();
}${!ClassExporter.hasConstructor
            ? ` else {
__contract = new ${ClassExporter.className}();
}`
            : ''}`;
        let assertStr = '';
        if (isInit) {
            assertStr = `assert(isNull(__contract), "contract is already initialized");`;
        }
        else if (ClassExporter.hasConstructor) {
            assertStr = `assert(!isNull(__contract), "contract is not initialized");`;
        }
        let isVoid = returnType === 'void';
        let body = isInit
            ? `__contract = new ${ClassExporter.className}(${pramNames.join(', ')});`
            : `${!isVoid ? 'let res =  ' : ''}__contract.${name}(${pramNames.join(', ')});`;
        if (isInit) {
            name = '__deploy';
            parameters = origParams.map((node) => `${toString(node.name)}: ${toString(node.type)}${node.initializer ? ' = ' + toString(node.initializer) : ''}`);
            returnType = 'void';
        }
        if (isInit) {
            if (!decorators.some((decorator) => decorator.includes('exportAs'))) {
                decorators.push(`@exportAs("deploy")`);
                this.checkMethods('deploy');
            }
            else {
                let decorator = node.decorators.find((d) => toString(d.name) === 'exportAs');
                if (decorator.args.length == 1) {
                    this.checkMethods(toString(decorator.args[0]));
                }
            }
        }
        const hasMutateState = decorators.some((decorator) => {
            let res = decorator.includes('mutateState');
            return res;
        });
        this.sb.push(`${decorators.join('\n')}
export function ${name}(${parameters.join(', ')}): ${returnType} {
  ${createContractStr}
  ${privateCheck}
  ${assertStr}
  ${body}
  ${isInit || hasMutateState ? `__setState(__contract);` : ''}
  ${isVoid || isInit ? '' : 'return res;'}
}`);
    }
    visitClassDeclaration(node) {
        if ((0, JSONBuilder_1.isEntry)(node) && node.is(as_1.CommonFlags.EXPORT)) {
            let name = toString(node.name);
            if (ClassExporter.classSeen) {
                throw new Error(`Cannot export class ${name}. ${ClassExporter.className} already exported. `);
            }
            ClassExporter.classSeen = node;
            ClassExporter.hasConstructor = node.members.some((member) => {
                if (member instanceof as_1.MethodDeclaration) {
                    return toString(member.name) === 'constructor';
                }
                return false;
            });
            this.visit(node.members);
            this.sb.push(`
        @idenaBindgenIgnore
        export function allocate(size : u32) : usize {
          return __allocate(size);
        }`);
            node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
            let newStatements = utils_1.SimpleParser.parseTopLevel(this.sb.join('\n')).map((n) => {
                if (n instanceof as_1.FunctionDeclaration) {
                    n.flags = n.flags | as_1.CommonFlags.EXPORT;
                    n.flags = n.flags | as_1.CommonFlags.MODULE_EXPORT;
                }
                n.range = node.range;
                return n;
            });
            node.range.source.statements.push(...newStatements);
        }
    }
    get name() {
        return 'idenaBindgen';
    }
    static visit(source) {
        if (source.sourceKind != as_1.SourceKind.USER_ENTRY) {
            return;
        }
        let visitor = new ClassExporter();
        visitor.visit(source);
    }
}
exports.ClassExporter = ClassExporter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NFeHBvcnRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc0V4cG9ydGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQVF1QjtBQUV2QiwyQ0FBaUQ7QUFDakQsK0NBQXNDO0FBQ3RDLG1DQUFxQztBQUVyQyxNQUFNLFFBQVEsR0FBRyxrQkFBSyxDQUFDLFFBQVEsQ0FBQztBQUNoQyxNQUFNLGdCQUFnQixHQUFHLGlCQUFpQixDQUFDO0FBRTNDLE1BQWEsYUFBYyxTQUFRLDJCQUFjO0lBQy9DLEVBQUUsR0FBYSxFQUFFLENBQUM7SUFDbEIsTUFBTSxDQUFDLFNBQVMsQ0FBbUI7SUFDbkMsTUFBTSxDQUFDLGNBQWMsQ0FBVTtJQUUvQixNQUFNLEtBQUssU0FBUztRQUNsQixPQUFPLFFBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxZQUFZLENBQUMsSUFBWTtRQUN2QixJQUFJLE1BQU0sR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDaEMsSUFDRSxNQUFNLFlBQVksc0JBQWlCO2dCQUNuQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQVcsQ0FBQyxPQUFPLENBQUMsRUFDL0I7Z0JBQ0EsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRTtvQkFDbEMsTUFBTSxJQUFJLEtBQUssQ0FDYixXQUFXLFFBQVEsQ0FDakIsTUFBTSxDQUFDLElBQUksQ0FDWixnRUFBZ0UsQ0FDbEUsQ0FBQztpQkFDSDthQUNGO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQscUJBQXFCLENBQUMsSUFBc0IsSUFBUyxDQUFDO0lBRXRELHNCQUFzQixDQUFDLElBQXVCO1FBQzVDLElBQUksSUFBSSxDQUFD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LEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBVyxDQUFDLE1BQU0sQ0FBQztZQUM3QyxJQUFJLGFBQWEsR0FBRyxvQkFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FDcEUsQ0FBQyxDQUFDLEVBQUUsRUFBRTtnQkFDSixJQUFJLENBQUMsWUFBWSx3QkFBbUIsRUFBRTtvQkFDcEMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLGdCQUFXLENBQUMsTUFBTSxDQUFDO29CQUN2QyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsZ0JBQVcsQ0FBQyxhQUFhLENBQUM7aUJBQy9DO2dCQUNELENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDckIsT0FBTyxDQUFDLENBQUM7WUFDWCxDQUFDLENBQ0YsQ0FBQztZQUNGLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQztTQUNyRDtJQUNILENBQUM7SUFFRCxJQUFJLElBQUk7UUFDTixPQUFPLGNBQWMsQ0FBQztJQUN4QixDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFjO1FBQ3pCLElBQUksTUFBTSxDQUFDLFVBQVUsSUFBSSxlQUFVLENBQUMsVUFBVSxFQUFFO1lBQzlDLE9BQU87U0FDUjtRQUNELElBQUksT0FBTyxHQUFHLElBQUksYUFBYSxFQUFFLENBQUM7UUFDbEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QixDQUFDO0NBQ0Y7QUExS0Qsc0NBMEtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2xhc3NEZWNsYXJhdGlvbixcbiAgRmllbGREZWNsYXJhdGlvbixcbiAgTWV0aG9kRGVjbGFyYXRpb24sXG4gIFNvdXJjZSxcbiAgQ29tbW9uRmxhZ3MsXG4gIFNvdXJjZUtpbmQsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG59IGZyb20gJ3Zpc2l0b3ItYXMvYXMnO1xuXG5pbXBvcnQge3V0aWxzLCBDbGFzc0RlY29yYXRvcn0gZnJvbSAndmlzaXRvci1hcyc7XG5pbXBvcnQge2lzRW50cnl9IGZyb20gJy4vSlNPTkJ1aWxkZXInO1xuaW1wb3J0IHtTaW1wbGVQYXJzZXJ9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCB0b1N0cmluZyA9IHV0aWxzLnRvU3RyaW5nO1xuY29uc3QgcHJpdmF0ZURlY29yYXRvciA9ICdjb250cmFjdFByaXZhdGUnO1xuXG5leHBvcnQgY2xhc3MgQ2xhc3NFeHBvcnRlciBleHRlbmRzIENsYXNzRGVjb3JhdG9yIHtcbiAgc2I6IHN0cmluZ1tdID0gW107XG4gIHN0YXRpYyBjbGFzc1NlZW46IENsYXNzRGVjbGFyYXRpb247XG4gIHN0YXRpYyBoYXNDb25zdHJ1Y3RvcjogYm9vbGVhbjtcblxuICBzdGF0aWMgZ2V0IGNsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyhDbGFzc0V4cG9ydGVyLmNsYXNzU2Vlbi5uYW1lKTtcbiAgfVxuXG4gIGNoZWNrTWV0aG9kcyhuYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgX2NsYXNzID0gQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW47XG4gICAgX2NsYXNzLm1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIG1lbWJlciBpbnN0YW5jZW9mIE1ldGhvZERlY2xhcmF0aW9uICYmXG4gICAgICAgICFtZW1iZXIuaXMoQ29tbW9uRmxhZ3MuUFJJVkFURSlcbiAgICAgICkge1xuICAgICAgICBpZiAodG9TdHJpbmcobWVtYmVyLm5hbWUpID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE1ldGhvZCBcIiR7dG9TdHJpbmcoXG4gICAgICAgICAgICAgIG1lbWJlci5uYW1lXG4gICAgICAgICAgICApfVwiIGFscmVhZHkgdXNlZDsgY2Fubm90IGV4cG9ydCBjb25zdHJ1Y3RvciB1c2luZyB0aGUgc2FtZSBuYW1lLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2aXNpdEZpZWxkRGVjbGFyYXRpb24obm9kZTogRmllbGREZWNsYXJhdGlvbik6IHZvaWQge31cblxuICB2aXNpdE1ldGhvZERlY2xhcmF0aW9uKG5vZGU6IE1ldGhvZERlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuU0VUKSB8fCBub2RlLmlzKENvbW1vbkZsYWdzLkdFVCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0V4cG9ydGVkIFNpbmdsZXRvbiBjbGFzcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzLiBGb3VuZCAnICtcbiAgICAgICAgICBub2RlLm5hbWUudGV4dFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzIHNob3VsZCBiZSBza2lwcGVkLlxuICAgIGlmIChub2RlLmlzKENvbW1vbkZsYWdzLlBSSVZBVEUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcml2YXRlQ2hlY2sgPSB1dGlscy5oYXNEZWNvcmF0b3Iobm9kZSwgcHJpdmF0ZURlY29yYXRvcilcbiAgICAgID8gYF9fYXNzZXJ0UHJpdmF0ZSgpO2BcbiAgICAgIDogJyc7XG4gICAgbGV0IG5hbWUgPSB0b1N0cmluZyhub2RlLm5hbWUpO1xuICAgIGxldCBkZWNvcmF0b3JzID0gKG5vZGUuZGVjb3JhdG9ycyB8fCBbXSkubWFwKHRvU3RyaW5nKTtcbiAgICBsZXQgcmV0dXJuVHlwZSA9IHRvU3RyaW5nKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpO1xuICAgIGxldCBvcmlnUGFyYW1zID0gbm9kZS5zaWduYXR1cmUucGFyYW1ldGVycy5tYXAodXRpbHMuY2xvbmVOb2RlKTtcbiAgICBsZXQgcGFyYW1ldGVycyA9IG9yaWdQYXJhbXMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgaWYgKHBhcmFtLmltcGxpY2l0RmllbGREZWNsYXJhdGlvbikge1xuICAgICAgICBwYXJhbS5uYW1lLnRleHQgPSBwYXJhbS5uYW1lLnRleHQuc3Vic3RyaW5nKDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvU3RyaW5nKHBhcmFtKTtcbiAgICB9KTtcbiAgICBsZXQgcHJhbU5hbWVzID0gb3JpZ1BhcmFtcy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocGFyYW0ubmFtZSk7XG4gICAgfSk7XG4gICAgbGV0IGlzSW5pdCA9IG5hbWUgPT09ICdjb25zdHJ1Y3Rvcic7XG5cbiAgICBsZXQgY3JlYXRlQ29udHJhY3RTdHIgPSBgbGV0IF9fY29udHJhY3Q6ICR7Q2xhc3NFeHBvcnRlci5jbGFzc05hbWV9O1xuaWYgKF9fY2hlY2tTdGF0ZSgpKSB7XG5fX2NvbnRyYWN0ID0gX19nZXRTdGF0ZTwke0NsYXNzRXhwb3J0ZXIuY2xhc3NOYW1lfT4oKTtcbn0ke1xuICAgICAgIUNsYXNzRXhwb3J0ZXIuaGFzQ29uc3RydWN0b3JcbiAgICAgICAgPyBgIGVsc2Uge1xuX19jb250cmFjdCA9IG5ldyAke0NsYXNzRXhwb3J0ZXIuY2xhc3NOYW1lfSgpO1xufWBcbiAgICAgICAgOiAnJ1xuICAgIH1gO1xuXG4gICAgbGV0IGFzc2VydFN0cjogc3RyaW5nID0gJyc7XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgYXNzZXJ0U3RyID0gYGFzc2VydChpc051bGwoX19jb250cmFjdCksIFwiY29udHJhY3QgaXMgYWxyZWFkeSBpbml0aWFsaXplZFwiKTtgO1xuICAgIH0gZWxzZSBpZiAoQ2xhc3NFeHBvcnRlci5oYXNDb25zdHJ1Y3Rvcikge1xuICAgICAgYXNzZXJ0U3RyID0gYGFzc2VydCghaXNOdWxsKF9fY29udHJhY3QpLCBcImNvbnRyYWN0IGlzIG5vdCBpbml0aWFsaXplZFwiKTtgO1xuICAgIH1cbiAgICBsZXQgaXNWb2lkID0gcmV0dXJuVHlwZSA9PT0gJ3ZvaWQnO1xuICAgIGxldCBib2R5ID0gaXNJbml0XG4gICAgICA/IGBfX2NvbnRyYWN0ID0gbmV3ICR7Q2xhc3NFeHBvcnRlci5jbGFzc05hbWV9KCR7cHJhbU5hbWVzLmpvaW4oJywgJyl9KTtgXG4gICAgICA6IGAkeyFpc1ZvaWQgPyAnbGV0IHJlcyA9ICAnIDogJyd9X19jb250cmFjdC4ke25hbWV9KCR7cHJhbU5hbWVzLmpvaW4oXG4gICAgICAgICAgJywgJ1xuICAgICAgICApfSk7YDtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBuYW1lID0gJ19fZGVwbG95JztcbiAgICAgIHBhcmFtZXRlcnMgPSBvcmlnUGFyYW1zLm1hcChcbiAgICAgICAgKG5vZGUpID0+XG4gICAgICAgICAgYCR7dG9TdHJpbmcobm9kZS5uYW1lKX06ICR7dG9TdHJpbmcobm9kZS50eXBlKX0ke1xuICAgICAgICAgICAgbm9kZS5pbml0aWFsaXplciA/ICcgPSAnICsgdG9TdHJpbmcobm9kZS5pbml0aWFsaXplcikgOiAnJ1xuICAgICAgICAgIH1gXG4gICAgICApO1xuICAgICAgcmV0dXJuVHlwZSA9ICd2b2lkJztcbiAgICB9XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgaWYgKCFkZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLmluY2x1ZGVzKCdleHBvcnRBcycpKSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2goYEBleHBvcnRBcyhcImRlcGxveVwiKWApO1xuICAgICAgICB0aGlzLmNoZWNrTWV0aG9kcygnZGVwbG95Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVjb3JhdG9yID0gbm9kZS5kZWNvcmF0b3JzIS5maW5kKFxuICAgICAgICAgIChkKSA9PiB0b1N0cmluZyhkLm5hbWUpID09PSAnZXhwb3J0QXMnXG4gICAgICAgICkhO1xuICAgICAgICBpZiAoZGVjb3JhdG9yLmFyZ3MhLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgdGhpcy5jaGVja01ldGhvZHModG9TdHJpbmcoZGVjb3JhdG9yLmFyZ3MhWzBdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFzTXV0YXRlU3RhdGUgPSBkZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4ge1xuICAgICAgbGV0IHJlcyA9IGRlY29yYXRvci5pbmNsdWRlcygnbXV0YXRlU3RhdGUnKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgdGhpcy5zYi5wdXNoKFxuICAgICAgYCR7ZGVjb3JhdG9ycy5qb2luKCdcXG4nKX1cbmV4cG9ydCBmdW5jdGlvbiAke25hbWV9KCR7cGFyYW1ldGVycy5qb2luKCcsICcpfSk6ICR7cmV0dXJuVHlwZX0ge1xuICAke2NyZWF0ZUNvbnRyYWN0U3RyfVxuICAke3ByaXZhdGVDaGVja31cbiAgJHthc3NlcnRTdHJ9XG4gICR7Ym9keX1cbiAgJHtpc0luaXQgfHwgaGFzTXV0YXRlU3RhdGUgPyBgX19zZXRTdGF0ZShfX2NvbnRyYWN0KTtgIDogJyd9XG4gICR7aXNWb2lkIHx8IGlzSW5pdCA/ICcnIDogJ3JldHVybiByZXM7J31cbn1gXG4gICAgKTtcbiAgfVxuXG4gIHZpc2l0Q2xhc3NEZWNsYXJhdGlvbihub2RlOiBDbGFzc0RlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgaWYgKGlzRW50cnkobm9kZSkgJiYgbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpKSB7XG4gICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKG5vZGUubmFtZSk7XG4gICAgICBpZiAoQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgZXhwb3J0IGNsYXNzICR7bmFtZX0uICR7Q2xhc3NFeHBvcnRlci5jbGFzc05hbWV9IGFscmVhZHkgZXhwb3J0ZWQuIGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIENsYXNzRXhwb3J0ZXIuY2xhc3NTZWVuID0gbm9kZTtcbiAgICAgIENsYXNzRXhwb3J0ZXIuaGFzQ29uc3RydWN0b3IgPSBub2RlLm1lbWJlcnMuc29tZSgobWVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChtZW1iZXIgaW5zdGFuY2VvZiBNZXRob2REZWNsYXJhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0b1N0cmluZyhtZW1iZXIubmFtZSkgPT09ICdjb25zdHJ1Y3Rvcic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7ICAgICAgXG4gICAgICB0aGlzLnZpc2l0KG5vZGUubWVtYmVycyk7XG4gICAgICB0aGlzLnNiLnB1c2goXG4gICAgICAgIGBcbiAgICAgICAgQGlkZW5hQmluZGdlbklnbm9yZVxuICAgICAgICBleHBvcnQgZnVuY3Rpb24gYWxsb2NhdGUoc2l6ZSA6IHUzMikgOiB1c2l6ZSB7XG4gICAgICAgICAgcmV0dXJuIF9fYWxsb2NhdGUoc2l6ZSk7XG4gICAgICAgIH1gXG4gICAgICApO1xuICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgXiBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgICBsZXQgbmV3U3RhdGVtZW50cyA9IFNpbXBsZVBhcnNlci5wYXJzZVRvcExldmVsKHRoaXMuc2Iuam9pbignXFxuJykpLm1hcChcbiAgICAgICAgKG4pID0+IHtcbiAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIG4uZmxhZ3MgPSBuLmZsYWdzIHwgQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgICAgICAgICAgbi5mbGFncyA9IG4uZmxhZ3MgfCBDb21tb25GbGFncy5NT0RVTEVfRVhQT1JUO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuLnJhbmdlID0gbm9kZS5yYW5nZTtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIG5vZGUucmFuZ2Uuc291cmNlLnN0YXRlbWVudHMucHVzaCguLi5uZXdTdGF0ZW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnaWRlbmFCaW5kZ2VuJztcbiAgfVxuXG4gIHN0YXRpYyB2aXNpdChzb3VyY2U6IFNvdXJjZSk6IHZvaWQge1xuICAgIGlmIChzb3VyY2Uuc291cmNlS2luZCAhPSBTb3VyY2VLaW5kLlVTRVJfRU5UUlkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZpc2l0b3IgPSBuZXcgQ2xhc3NFeHBvcnRlcigpO1xuICAgIHZpc2l0b3IudmlzaXQoc291cmNlKTtcbiAgfVxufVxuIl19