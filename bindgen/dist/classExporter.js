"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassExporter = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const JSONBuilder_1 = require("./JSONBuilder");
const utils_1 = require("./utils");
const toString = visitor_as_1.utils.toString;
const privateDecorator = "contractPrivate";
class ClassExporter extends visitor_as_1.ClassDecorator {
    constructor() {
        super(...arguments);
        this.sb = [];
    }
    static get className() {
        return toString(ClassExporter.classSeen.name);
    }
    checkMethods(name) {
        let _class = ClassExporter.classSeen;
        _class.members.forEach((member) => {
            if (member instanceof as_1.MethodDeclaration &&
                !member.is(as_1.CommonFlags.PRIVATE)) {
                if (toString(member.name) === name) {
                    throw new Error(`Method "${toString(member.name)}" already used; cannot export constructor using the same name.`);
                }
            }
        });
    }
    visitFieldDeclaration(node) { }
    visitMethodDeclaration(node) {
        if (node.is(as_1.CommonFlags.SET) || node.is(as_1.CommonFlags.GET)) {
            throw new Error("Exported Singleton class cannot have properties. Found " +
                node.name.text);
        }
        // Private methods should be skipped.
        if (node.is(as_1.CommonFlags.PRIVATE)) {
            return;
        }
        let privateCheck = visitor_as_1.utils.hasDecorator(node, privateDecorator)
            ? `__assertPrivate();`
            : "";
        let name = toString(node.name);
        let decorators = (node.decorators || []).map(toString);
        let returnType = toString(node.signature.returnType);
        let origParams = node.signature.parameters.map(visitor_as_1.utils.cloneNode);
        let parameters = origParams.map((param) => {
            if (param.implicitFieldDeclaration) {
                param.name.text = param.name.text.substring(2);
            }
            return toString(param);
        });
        let pramNames = origParams.map((param) => {
            return toString(param.name);
        });
        let isInit = name === "constructor";
        let assertStr = "";
        if (isInit) {
            assertStr = `assert(isNull(__contract), "contract is already initialized");`;
        }
        else if (ClassExporter.hasConstructor) {
            assertStr = `assert(!isNull(__contract), "contract is not initialized");`;
        }
        let isVoid = returnType === "void";
        let body = isInit
            ? `__contract = new ${ClassExporter.className}(${pramNames.join(", ")});`
            : `${!isVoid ? "let res =  " : ""}__contract.${name}(${pramNames.join(", ")});`;
        if (isInit) {
            name = "init";
            parameters = origParams.map((node) => `${toString(node.name)}: ${toString(node.type)}${node.initializer ? " = " + toString(node.initializer) : ""}`);
            returnType = "void";
        }
        if (isInit) {
            if (!decorators.some((decorator) => decorator.includes("exportAs"))) {
                decorators.push(`@exportAs("deploy")`);
                this.checkMethods("deploy");
            }
            else {
                let decorator = node.decorators.find((d) => toString(d.name) === "exportAs");
                if (decorator.args.length == 1) {
                    this.checkMethods(toString(decorator.args[0]));
                }
            }
        }
        const hasMutateState = decorators.some((decorator) => {
            let res = decorator.includes("mutateState");
            return res;
        });
        this.sb.push(`${decorators.join("\n")}
export function ${name}(${parameters.join(", ")}): ${returnType} {
  ${privateCheck}
  ${assertStr}
  ${body}
  ${isInit || hasMutateState ? `__setState(__contract);` : ""}
  ${isVoid || isInit ? "" : "return res;"}
}`);
    }
    visitClassDeclaration(node) {
        if (JSONBuilder_1.isEntry(node) && node.is(as_1.CommonFlags.EXPORT)) {
            let name = toString(node.name);
            if (ClassExporter.classSeen) {
                throw new Error(`Cannot export class ${name}. ${ClassExporter.className} already exported. `);
            }
            ClassExporter.classSeen = node;
            ClassExporter.hasConstructor = node.members.some((member) => {
                if (member instanceof as_1.MethodDeclaration) {
                    return toString(member.name) === "constructor";
                }
                return false;
            });
            this.sb.push(`let __contract: ${name};
if (__checkState()) {
  __contract = __getState<${name}>();
}${!ClassExporter.hasConstructor
                ? ` else {
  __contract = new ${name}();
}`
                : ""}`);
            this.visit(node.members);
            node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
            let newStatements = utils_1.SimpleParser.parseTopLevel(this.sb.join("\n")).map((n) => {
                if (n instanceof as_1.FunctionDeclaration) {
                    n.flags = n.flags | as_1.CommonFlags.EXPORT;
                    n.flags = n.flags | as_1.CommonFlags.MODULE_EXPORT;
                }
                n.range = node.range;
                return n;
            });
            node.range.source.statements.push(...newStatements);
        }
    }
    get name() {
        return "idenaBindgen";
    }
    static visit(source) {
        if (source.sourceKind != as_1.SourceKind.USER_ENTRY) {
            return;
        }
        let visitor = new ClassExporter();
        visitor.visit(source);
    }
}
exports.ClassExporter = ClassExporter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NFeHBvcnRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc0V4cG9ydGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQVF1QjtBQUV2QiwyQ0FBbUQ7QUFDbkQsK0NBQXdDO0FBQ3hDLG1DQUF1QztBQUV2QyxNQUFNLFFBQVEsR0FBRyxrQkFBSyxDQUFDLFFBQVEsQ0FBQztBQUNoQyxNQUFNLGdCQUFnQixHQUFHLGlCQUFpQixDQUFDO0FBRTNDLE1BQWEsYUFBYyxTQUFRLDJCQUFjO0lBQWpEOztRQUNFLE9BQUUsR0FBYSxFQUFFLENBQUM7SUFpS3BCLENBQUM7SUE3SkMsTUFBTSxLQUFLLFNBQVM7UUFDbEIsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQsWUFBWSxDQUFDLElBQVk7UUFDdkIsSUFBSSxNQUFNLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQztRQUNyQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2hDLElBQ0UsTUFBTSxZQUFZLHNCQUFpQjtnQkFDbkMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLGdCQUFXLENBQUMsT0FBTyxDQUFDLEVBQy9CO2dCQUNBLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQ2IsV0FBVyxRQUFRLENBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQ1osZ0VBQWdFLENBQ2xFLENBQUM7aUJBQ0g7YUFDRjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHFCQUFxQixDQUFDLElBQXNCLElBQVMsQ0FBQztJQUV0RCxzQkFBc0IsQ0FBQyxJQUF1QjtRQUM1QyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQVcsQ0FBQyxHQUFHLENBQUMsSUFB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LElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUNwRSxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNKLElBQUksQ0FBQyxZQUFZLHdCQUFtQixFQUFFO29CQUNwQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsZ0JBQVcsQ0FBQyxNQUFNLENBQUM7b0JBQ3ZDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxnQkFBVyxDQUFDLGFBQWEsQ0FBQztpQkFDL0M7Z0JBQ0QsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUNyQixPQUFPLENBQUMsQ0FBQztZQUNYLENBQUMsQ0FDRixDQUFDO1lBQ0YsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDO1NBQ3JEO0lBQ0gsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sY0FBYyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQWM7UUFDekIsSUFBSSxNQUFNLENBQUMsVUFBVSxJQUFJLGVBQVUsQ0FBQyxVQUFVLEVBQUU7WUFDOUMsT0FBTztTQUNSO1FBQ0QsSUFBSSxPQUFPLEdBQUcsSUFBSSxhQUFhLEVBQUUsQ0FBQztRQUNsQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hCLENBQUM7Q0FDRjtBQWxLRCxzQ0FrS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDbGFzc0RlY2xhcmF0aW9uLFxuICBGaWVsZERlY2xhcmF0aW9uLFxuICBNZXRob2REZWNsYXJhdGlvbixcbiAgU291cmNlLFxuICBDb21tb25GbGFncyxcbiAgU291cmNlS2luZCxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbn0gZnJvbSBcInZpc2l0b3ItYXMvYXNcIjtcblxuaW1wb3J0IHsgdXRpbHMsIENsYXNzRGVjb3JhdG9yIH0gZnJvbSBcInZpc2l0b3ItYXNcIjtcbmltcG9ydCB7IGlzRW50cnkgfSBmcm9tIFwiLi9KU09OQnVpbGRlclwiO1xuaW1wb3J0IHsgU2ltcGxlUGFyc2VyIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgdG9TdHJpbmcgPSB1dGlscy50b1N0cmluZztcbmNvbnN0IHByaXZhdGVEZWNvcmF0b3IgPSBcImNvbnRyYWN0UHJpdmF0ZVwiO1xuXG5leHBvcnQgY2xhc3MgQ2xhc3NFeHBvcnRlciBleHRlbmRzIENsYXNzRGVjb3JhdG9yIHtcbiAgc2I6IHN0cmluZ1tdID0gW107XG4gIHN0YXRpYyBjbGFzc1NlZW46IENsYXNzRGVjbGFyYXRpb247XG4gIHN0YXRpYyBoYXNDb25zdHJ1Y3RvcjogYm9vbGVhbjtcblxuICBzdGF0aWMgZ2V0IGNsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyhDbGFzc0V4cG9ydGVyLmNsYXNzU2Vlbi5uYW1lKTtcbiAgfVxuXG4gIGNoZWNrTWV0aG9kcyhuYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgX2NsYXNzID0gQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW47XG4gICAgX2NsYXNzLm1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIG1lbWJlciBpbnN0YW5jZW9mIE1ldGhvZERlY2xhcmF0aW9uICYmXG4gICAgICAgICFtZW1iZXIuaXMoQ29tbW9uRmxhZ3MuUFJJVkFURSlcbiAgICAgICkge1xuICAgICAgICBpZiAodG9TdHJpbmcobWVtYmVyLm5hbWUpID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE1ldGhvZCBcIiR7dG9TdHJpbmcoXG4gICAgICAgICAgICAgIG1lbWJlci5uYW1lXG4gICAgICAgICAgICApfVwiIGFscmVhZHkgdXNlZDsgY2Fubm90IGV4cG9ydCBjb25zdHJ1Y3RvciB1c2luZyB0aGUgc2FtZSBuYW1lLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2aXNpdEZpZWxkRGVjbGFyYXRpb24obm9kZTogRmllbGREZWNsYXJhdGlvbik6IHZvaWQge31cblxuICB2aXNpdE1ldGhvZERlY2xhcmF0aW9uKG5vZGU6IE1ldGhvZERlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuU0VUKSB8fCBub2RlLmlzKENvbW1vbkZsYWdzLkdFVCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBvcnRlZCBTaW5nbGV0b24gY2xhc3MgY2Fubm90IGhhdmUgcHJvcGVydGllcy4gRm91bmQgXCIgK1xuICAgICAgICAgIG5vZGUubmFtZS50ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICAvLyBQcml2YXRlIG1ldGhvZHMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuUFJJVkFURSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByaXZhdGVDaGVjayA9IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBwcml2YXRlRGVjb3JhdG9yKVxuICAgICAgPyBgX19hc3NlcnRQcml2YXRlKCk7YFxuICAgICAgOiBcIlwiO1xuICAgIGxldCBuYW1lID0gdG9TdHJpbmcobm9kZS5uYW1lKTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IChub2RlLmRlY29yYXRvcnMgfHwgW10pLm1hcCh0b1N0cmluZyk7XG4gICAgbGV0IHJldHVyblR5cGUgPSB0b1N0cmluZyhub2RlLnNpZ25hdHVyZS5yZXR1cm5UeXBlKTtcbiAgICBsZXQgb3JpZ1BhcmFtcyA9IG5vZGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMubWFwKHV0aWxzLmNsb25lTm9kZSk7XG4gICAgbGV0IHBhcmFtZXRlcnMgPSBvcmlnUGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgIGlmIChwYXJhbS5pbXBsaWNpdEZpZWxkRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcGFyYW0ubmFtZS50ZXh0ID0gcGFyYW0ubmFtZS50ZXh0LnN1YnN0cmluZygyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b1N0cmluZyhwYXJhbSk7XG4gICAgfSk7XG4gICAgbGV0IHByYW1OYW1lcyA9IG9yaWdQYXJhbXMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHBhcmFtLm5hbWUpO1xuICAgIH0pO1xuICAgIGxldCBpc0luaXQgPSBuYW1lID09PSBcImNvbnN0cnVjdG9yXCI7XG4gICAgbGV0IGFzc2VydFN0cjogc3RyaW5nID0gXCJcIjtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBhc3NlcnRTdHIgPSBgYXNzZXJ0KGlzTnVsbChfX2NvbnRyYWN0KSwgXCJjb250cmFjdCBpcyBhbHJlYWR5IGluaXRpYWxpemVkXCIpO2A7XG4gICAgfSBlbHNlIGlmIChDbGFzc0V4cG9ydGVyLmhhc0NvbnN0cnVjdG9yKSB7XG4gICAgICBhc3NlcnRTdHIgPSBgYXNzZXJ0KCFpc051bGwoX19jb250cmFjdCksIFwiY29udHJhY3QgaXMgbm90IGluaXRpYWxpemVkXCIpO2A7XG4gICAgfVxuICAgIGxldCBpc1ZvaWQgPSByZXR1cm5UeXBlID09PSBcInZvaWRcIjtcbiAgICBsZXQgYm9keSA9IGlzSW5pdFxuICAgICAgPyBgX19jb250cmFjdCA9IG5ldyAke0NsYXNzRXhwb3J0ZXIuY2xhc3NOYW1lfSgke3ByYW1OYW1lcy5qb2luKFwiLCBcIil9KTtgXG4gICAgICA6IGAkeyFpc1ZvaWQgPyBcImxldCByZXMgPSAgXCIgOiBcIlwifV9fY29udHJhY3QuJHtuYW1lfSgke3ByYW1OYW1lcy5qb2luKFxuICAgICAgICAgIFwiLCBcIlxuICAgICAgICApfSk7YDtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBuYW1lID0gXCJpbml0XCI7XG4gICAgICBwYXJhbWV0ZXJzID0gb3JpZ1BhcmFtcy5tYXAoXG4gICAgICAgIChub2RlKSA9PlxuICAgICAgICAgIGAke3RvU3RyaW5nKG5vZGUubmFtZSl9OiAke3RvU3RyaW5nKG5vZGUudHlwZSl9JHtcbiAgICAgICAgICAgIG5vZGUuaW5pdGlhbGl6ZXIgPyBcIiA9IFwiICsgdG9TdHJpbmcobm9kZS5pbml0aWFsaXplcikgOiBcIlwiXG4gICAgICAgICAgfWBcbiAgICAgICk7XG4gICAgICByZXR1cm5UeXBlID0gXCJ2b2lkXCI7XG4gICAgfVxuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIGlmICghZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5pbmNsdWRlcyhcImV4cG9ydEFzXCIpKSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2goYEBleHBvcnRBcyhcImRlcGxveVwiKWApO1xuICAgICAgICB0aGlzLmNoZWNrTWV0aG9kcyhcImRlcGxveVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZWNvcmF0b3IgPSBub2RlLmRlY29yYXRvcnMhLmZpbmQoXG4gICAgICAgICAgKGQpID0+IHRvU3RyaW5nKGQubmFtZSkgPT09IFwiZXhwb3J0QXNcIlxuICAgICAgICApITtcbiAgICAgICAgaWYgKGRlY29yYXRvci5hcmdzIS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tNZXRob2RzKHRvU3RyaW5nKGRlY29yYXRvci5hcmdzIVswXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhc011dGF0ZVN0YXRlID0gZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IHtcbiAgICAgIGxldCByZXMgPSBkZWNvcmF0b3IuaW5jbHVkZXMoXCJtdXRhdGVTdGF0ZVwiKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgdGhpcy5zYi5wdXNoKFxuICAgICAgYCR7ZGVjb3JhdG9ycy5qb2luKFwiXFxuXCIpfVxuZXhwb3J0IGZ1bmN0aW9uICR7bmFtZX0oJHtwYXJhbWV0ZXJzLmpvaW4oXCIsIFwiKX0pOiAke3JldHVyblR5cGV9IHtcbiAgJHtwcml2YXRlQ2hlY2t9XG4gICR7YXNzZXJ0U3RyfVxuICAke2JvZHl9XG4gICR7aXNJbml0IHx8IGhhc011dGF0ZVN0YXRlID8gYF9fc2V0U3RhdGUoX19jb250cmFjdCk7YCA6IFwiXCJ9XG4gICR7aXNWb2lkIHx8IGlzSW5pdCA/IFwiXCIgOiBcInJldHVybiByZXM7XCJ9XG59YFxuICAgICk7XG4gIH1cblxuICB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmIChpc0VudHJ5KG5vZGUpICYmIG5vZGUuaXMoQ29tbW9uRmxhZ3MuRVhQT1JUKSkge1xuICAgICAgbGV0IG5hbWUgPSB0b1N0cmluZyhub2RlLm5hbWUpO1xuICAgICAgaWYgKENsYXNzRXhwb3J0ZXIuY2xhc3NTZWVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IGV4cG9ydCBjbGFzcyAke25hbWV9LiAke0NsYXNzRXhwb3J0ZXIuY2xhc3NOYW1lfSBhbHJlYWR5IGV4cG9ydGVkLiBgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBDbGFzc0V4cG9ydGVyLmNsYXNzU2VlbiA9IG5vZGU7XG4gICAgICBDbGFzc0V4cG9ydGVyLmhhc0NvbnN0cnVjdG9yID0gbm9kZS5tZW1iZXJzLnNvbWUoKG1lbWJlcikgPT4ge1xuICAgICAgICBpZiAobWVtYmVyIGluc3RhbmNlb2YgTWV0aG9kRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdG9TdHJpbmcobWVtYmVyLm5hbWUpID09PSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNiLnB1c2goXG4gICAgICAgIGBsZXQgX19jb250cmFjdDogJHtuYW1lfTtcbmlmIChfX2NoZWNrU3RhdGUoKSkge1xuICBfX2NvbnRyYWN0ID0gX19nZXRTdGF0ZTwke25hbWV9PigpO1xufSR7XG4gICAgICAgICAgIUNsYXNzRXhwb3J0ZXIuaGFzQ29uc3RydWN0b3JcbiAgICAgICAgICAgID8gYCBlbHNlIHtcbiAgX19jb250cmFjdCA9IG5ldyAke25hbWV9KCk7XG59YFxuICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgICAgdGhpcy52aXNpdChub2RlLm1lbWJlcnMpO1xuICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgXiBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgICBsZXQgbmV3U3RhdGVtZW50cyA9IFNpbXBsZVBhcnNlci5wYXJzZVRvcExldmVsKHRoaXMuc2Iuam9pbihcIlxcblwiKSkubWFwKFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgbi5mbGFncyA9IG4uZmxhZ3MgfCBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgICAgICAgICBuLmZsYWdzID0gbi5mbGFncyB8IENvbW1vbkZsYWdzLk1PRFVMRV9FWFBPUlQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4ucmFuZ2UgPSBub2RlLnJhbmdlO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbm9kZS5yYW5nZS5zb3VyY2Uuc3RhdGVtZW50cy5wdXNoKC4uLm5ld1N0YXRlbWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiaWRlbmFCaW5kZ2VuXCI7XG4gIH1cblxuICBzdGF0aWMgdmlzaXQoc291cmNlOiBTb3VyY2UpOiB2b2lkIHtcbiAgICBpZiAoc291cmNlLnNvdXJjZUtpbmQgIT0gU291cmNlS2luZC5VU0VSX0VOVFJZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB2aXNpdG9yID0gbmV3IENsYXNzRXhwb3J0ZXIoKTtcbiAgICB2aXNpdG9yLnZpc2l0KHNvdXJjZSk7XG4gIH1cbn1cbiJdfQ==