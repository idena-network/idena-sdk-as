"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONBindingsBuilder = exports.isUserFile = exports.isEntry = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const utils_1 = require("./utils");
const IDENA_DECORATOR = 'idenaBindgen';
const IDENA_IGNORE_FUNC_DECORATOR = 'idenaBindgenIgnore';
const WRAPPER_PREFIX = '__wrapper_';
function returnsVoid(node) {
    return (0, utils_1.toString)(node.signature.returnType) === 'void';
}
function numOfParameters(node) {
    return node.signature.parameters.length;
}
function hasIdenaDecorator(stmt) {
    const res = isUserFile(stmt) ||
        stmt.statements.some((s) => s instanceof as_1.DeclarationStatement &&
            visitor_as_1.utils.hasDecorator(s, IDENA_DECORATOR));
    if (res) {
        console.log(`transformed file path=${stmt.normalizedPath} entry=${stmt.range.source.sourceKind}`);
    }
    return res;
}
function isEntry(source) {
    return source.range.source.sourceKind == as_1.SourceKind.USER_ENTRY;
}
exports.isEntry = isEntry;
function isUserFile(source) {
    return (source.range.source.sourceKind == as_1.SourceKind.USER_ENTRY ||
        source.range.source.sourceKind == as_1.SourceKind.USER);
}
exports.isUserFile = isUserFile;
function isClass(type) {
    return type.kind == as_1.NodeKind.CLASSDECLARATION;
}
function isField(mem) {
    return mem.kind == as_1.NodeKind.FIELDDECLARATION;
}
function isStatic(mem) {
    return mem.is(as_1.CommonFlags.STATIC);
}
function isEncodable(mem) {
    return isField(mem) && !isStatic(mem);
}
function isPayable(func) {
    return (func.decorators != null &&
        func.decorators.some((s) => (0, utils_1.toString)(s.name) != 'payable'));
}
function createDecodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        const name = (0, utils_1.toString)(field.name);
        return (createDecodeStatement(field, `this.${name} = obj.has("${name}") ? `) +
            `: ${field.initializer != null
                ? (0, utils_1.toString)(field.initializer)
                : `this.${name}`};`);
    });
}
function createPtrDecodeStatement(field, setterPrefix = '') {
    let T = (0, utils_1.toString)(field.type);
    let name = (0, utils_1.toString)(field.name);
    return `${setterPrefix}readRegion<${T}>(${name})`;
}
function createDecodeStatement(field, setterPrefix = '') {
    let T = (0, utils_1.toString)(field.type);
    let name = (0, utils_1.toString)(field.name);
    return `${setterPrefix}decode<${T}, JSON.Obj>(obj, "${name}")`;
}
function createEncodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        let T = (0, utils_1.toString)(field.type);
        let name = (0, utils_1.toString)(field.name);
        return `encode<${T}, JSONEncoder>(this.${name}, "${name}", encoder);`;
    });
}
// TODO: Extract this into separate module, preferrable pluggable
class JSONBindingsBuilder extends visitor_as_1.BaseVisitor {
    sb = [];
    exportedClasses = new Map();
    static isTest = false;
    wrappedFuncs = new Set();
    static build(source) {
        return new JSONBindingsBuilder().build(source);
    }
    static idenaFiles(sources) {
        return sources.filter(hasIdenaDecorator);
    }
    static checkTestBuild(sources) {
        this.isTest = sources.some((s) => s.normalizedPath.includes('.spec.'));
    }
    visitClassDeclaration(node) {
        if (!this.exportedClasses.has((0, utils_1.toString)(node.name))) {
            this.exportedClasses.set((0, utils_1.toString)(node.name), node);
        }
        super.visitClassDeclaration(node);
    }
    needsWrapper(node) {
        let isExport = node.is(as_1.CommonFlags.EXPORT);
        let alreadyWrapped = this.wrappedFuncs.has((0, utils_1.toString)(node.name));
        let noInputOrOutput = numOfParameters(node) == 0 && returnsVoid(node);
        let isIgnore = visitor_as_1.utils.hasDecorator(node, IDENA_IGNORE_FUNC_DECORATOR);
        if (isIgnore ||
            !isExport ||
            alreadyWrapped ||
            noInputOrOutput ||
            JSONBindingsBuilder.isTest)
            return false;
        return isEntry(node) || visitor_as_1.utils.hasDecorator(node, IDENA_DECORATOR);
    }
    visitFunctionDeclaration(node) {
        if (!this.needsWrapper(node)) {
            if ((isEntry(node) || visitor_as_1.utils.hasDecorator(node, IDENA_DECORATOR)) &&
                !this.wrappedFuncs.has((0, utils_1.toString)(node.name)) &&
                node.is(as_1.CommonFlags.EXPORT)) {
                this.sb.push(this.camelCaseToSnakeCaseExport((0, utils_1.toString)(node.name), ''));
                this.wrappedFuncs.add((0, utils_1.toString)(node.name));
            }
            super.visitFunctionDeclaration(node);
            return;
        }
        this.generateWrapperFunction(node);
        // Change function to not be an export
        node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add((0, utils_1.toString)(node.name));
        super.visit(node);
    }
    camelCaseToSnakeCaseExport(name, prefix = WRAPPER_PREFIX) {
        let s = (0, utils_1.makeSnakeCase)(name);
        if (s.normalize() === name.normalize()) {
            return '';
        }
        return `export { ${prefix + name} as ${s} }`;
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = (0, utils_1.toString)(returnType)
            .split('|')
            .map((name) => name.trim())
            .filter((name) => name !== 'null')
            .join('|');
        let hasNull = (0, utils_1.toString)(returnType).includes('null');
        let name = func.name.text;
        if (func.decorators && func.decorators.length > 0) {
            this.sb.push(func.decorators.map((decorator) => (0, utils_1.toString)(decorator)).join('\n'));
        }
        var ptrParamsSb = params
            .map((param) => {
            let name = (0, utils_1.toString)(param.name);
            return `${name} : u32`;
        })
            .join(', ');
        var wrappedReturnType = 'void';
        if ((0, utils_1.toString)(returnType) !== 'void') {
            wrappedReturnType = 'usize';
        }
        this.sb.push(`function __wrapper_${name}(${ptrParamsSb}): ${wrappedReturnType} {`);
        if ((0, utils_1.toString)(returnType) !== 'void') {
            this.sb.push(`  let result: ${(0, utils_1.toString)(returnType)} = ${name}(`);
        }
        else {
            this.sb.push(`  ${name}(`);
        }
        if (params.length > 0) {
            this.sb[this.sb.length - 1] += params
                .map((param) => {
                let name = (0, utils_1.toString)(param.name);
                let type = (0, utils_1.toString)(param.type);
                let res = `${name}>0 ? ${createPtrDecodeStatement(param)} : ${param.initializer
                    ? (0, utils_1.toString)(param.initializer)
                    : `requireParameter<${type}>("${name}")`}`;
                return res;
            })
                .join(',\n    ');
        }
        this.sb[this.sb.length - 1] += ');';
        if ((0, utils_1.toString)(returnType) !== 'void') {
            this.sb.push(`
      return write_region<${(0, utils_1.toString)(returnType)}>(result);`);
        }
        this.sb.push(`}
export { ${WRAPPER_PREFIX + name} as ${name} }
${this.camelCaseToSnakeCaseExport(name)}
`);
    }
    typeName(type) {
        if (!isClass(type)) {
            return (0, utils_1.toString)(type);
        }
        type = type;
        let className = (0, utils_1.toString)(type.name);
        if (type.isGeneric) {
            className += '<' + type.typeParameters.map(utils_1.toString).join(', ') + '>';
        }
        return className;
    }
    build(source) {
        this.sb = [];
        this.visit(source);
        let sourceText = source.statements.map((stmt) => {
            let str;
            if (isClass(stmt)) {
                let _class = stmt;
                let isIgnore = visitor_as_1.utils.hasDecorator(_class, IDENA_IGNORE_FUNC_DECORATOR);
                if (!isIgnore) {
                    let fields = _class.members
                        .filter(isField)
                        .map((field) => field);
                    if (fields.some((field) => field.type == null)) {
                        throw new Error('All Fields must have explicit type declaration.');
                    }
                    fields.forEach((field) => {
                        if (field.initializer == null) {
                            field.initializer = utils_1.SimpleParser.parseExpression(`defaultValue<${(0, utils_1.toString)(field.type)}>())`);
                        }
                    });
                    str = (0, utils_1.toString)(stmt);
                    str = str.slice(0, str.lastIndexOf('}'));
                    let className = this.typeName(_class);
                    str += `
  decode<_V = Uint8Array>(buf: _V): ${className} {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): ${className} {
    return decode<${className}>(buf);
  }

  private _decode(obj: JSON.Obj): ${className} {
    ${createDecodeStatements(_class).join('\n    ')}    
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    ${createEncodeStatements(_class).join('\n    ')}
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}`;
                }
                else {
                    str = (0, utils_1.toString)(stmt);
                }
            }
            else {
                str = (0, utils_1.toString)(stmt);
            }
            return str;
        });
        return sourceText.concat(this.sb).join('\n');
    }
}
exports.JSONBindingsBuilder = JSONBindingsBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTkJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvSlNPTkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0NBWXVCO0FBQ3ZCLDJDQUE4QztBQUM5QyxtQ0FBOEQ7QUFFOUQsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDO0FBQ3ZDLE1BQU0sMkJBQTJCLEdBQUcsb0JBQW9CLENBQUM7QUFDekQsTUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDO0FBRXBDLFNBQVMsV0FBVyxDQUFDLElBQXlCO0lBQzVDLE9BQU8sSUFBQSxnQkFBUSxFQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEtBQUssTUFBTSxDQUFDO0FBQ3hELENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxJQUF5QjtJQUNoRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztBQUMxQyxDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxJQUFZO0lBQ3JDLE1BQU0sR0FBRyxHQUNQLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFDaEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQ2xCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDSixDQUFDLFlBQVkseUJBQW9CO1lBQ2pDLGtCQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsQ0FDekMsQ0FBQztJQUNKLElBQUksR0FBRyxFQUFFO1FBQ1AsT0FBTyxDQUFDLEdBQUcsQ0FDVCx5QkFBeUIsSUFBSSxDQUFDLGNBQWMsVUFBVSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FDckYsQ0FBQztLQUNIO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQsU0FBZ0IsT0FBTyxDQUFDLE1BQXFCO0lBQzNDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLGVBQVUsQ0FBQyxV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b0JBQ3pCLFNBQVM7OztvQ0FHTyxTQUFTO01BQ3ZDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7TUFPN0Msc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0VBZWpELENBQUM7aUJBQ007cUJBQU07b0JBQ0wsR0FBRyxHQUFHLElBQUEsZ0JBQVEsRUFBQyxJQUFJLENBQUMsQ0FBQztpQkFDdEI7YUFDRjtpQkFBTTtnQkFDTCxHQUFHLEdBQUcsSUFBQSxnQkFBUSxFQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3RCO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9DLENBQUM7O0FBak9ILGtEQWtPQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIE5vZGUsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIE5vZGVLaW5kLFxuICBTb3VyY2UsXG4gIFNvdXJjZUtpbmQsXG4gIFR5cGVOb2RlLFxuICBDbGFzc0RlY2xhcmF0aW9uLFxuICBEZWNsYXJhdGlvblN0YXRlbWVudCxcbiAgQ29tbW9uRmxhZ3MsXG4gIEZpZWxkRGVjbGFyYXRpb24sXG4gIFBhcmFtZXRlck5vZGUsXG59IGZyb20gJ3Zpc2l0b3ItYXMvYXMnO1xuaW1wb3J0IHtCYXNlVmlzaXRvciwgdXRpbHN9IGZyb20gJ3Zpc2l0b3ItYXMnO1xuaW1wb3J0IHtTaW1wbGVQYXJzZXIsIHRvU3RyaW5nLCBtYWtlU25ha2VDYXNlfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgSURFTkFfREVDT1JBVE9SID0gJ2lkZW5hQmluZGdlbic7XG5jb25zdCBJREVOQV9JR05PUkVfRlVOQ19ERUNPUkFUT1IgPSAnaWRlbmFCaW5kZ2VuSWdub3JlJztcbmNvbnN0IFdSQVBQRVJfUFJFRklYID0gJ19fd3JhcHBlcl8nO1xuXG5mdW5jdGlvbiByZXR1cm5zVm9pZChub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiB0b1N0cmluZyhub2RlLnNpZ25hdHVyZS5yZXR1cm5UeXBlKSA9PT0gJ3ZvaWQnO1xufVxuXG5mdW5jdGlvbiBudW1PZlBhcmFtZXRlcnMobm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IG51bWJlciB7XG4gIHJldHVybiBub2RlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gaGFzSWRlbmFEZWNvcmF0b3Ioc3RtdDogU291cmNlKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJlcyA9XG4gICAgaXNVc2VyRmlsZShzdG10KSB8fFxuICAgIHN0bXQuc3RhdGVtZW50cy5zb21lKFxuICAgICAgKHMpID0+XG4gICAgICAgIHMgaW5zdGFuY2VvZiBEZWNsYXJhdGlvblN0YXRlbWVudCAmJlxuICAgICAgICB1dGlscy5oYXNEZWNvcmF0b3IocywgSURFTkFfREVDT1JBVE9SKVxuICAgICk7XG4gIGlmIChyZXMpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGB0cmFuc2Zvcm1lZCBmaWxlIHBhdGg9JHtzdG10Lm5vcm1hbGl6ZWRQYXRofSBlbnRyeT0ke3N0bXQucmFuZ2Uuc291cmNlLnNvdXJjZUtpbmR9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW50cnkoc291cmNlOiBTb3VyY2UgfCBOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzb3VyY2UucmFuZ2Uuc291cmNlLnNvdXJjZUtpbmQgPT0gU291cmNlS2luZC5VU0VSX0VOVFJZO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVc2VyRmlsZShzb3VyY2U6IFNvdXJjZSB8IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBzb3VyY2UucmFuZ2Uuc291cmNlLnNvdXJjZUtpbmQgPT0gU291cmNlS2luZC5VU0VSX0VOVFJZIHx8XG4gICAgc291cmNlLnJhbmdlLnNvdXJjZS5zb3VyY2VLaW5kID09IFNvdXJjZUtpbmQuVVNFUlxuICApO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzKHR5cGU6IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGUua2luZCA9PSBOb2RlS2luZC5DTEFTU0RFQ0xBUkFUSU9OO1xufVxuXG5mdW5jdGlvbiBpc0ZpZWxkKG1lbTogRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIG1lbS5raW5kID09IE5vZGVLaW5kLkZJRUxEREVDTEFSQVRJT047XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljKG1lbTogRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIG1lbS5pcyhDb21tb25GbGFncy5TVEFUSUMpO1xufVxuXG5mdW5jdGlvbiBpc0VuY29kYWJsZShtZW06IERlY2xhcmF0aW9uU3RhdGVtZW50KSB7XG4gIHJldHVybiBpc0ZpZWxkKG1lbSkgJiYgIWlzU3RhdGljKG1lbSk7XG59XG5cbmZ1bmN0aW9uIGlzUGF5YWJsZShmdW5jOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgZnVuYy5kZWNvcmF0b3JzICE9IG51bGwgJiZcbiAgICBmdW5jLmRlY29yYXRvcnMuc29tZSgocykgPT4gdG9TdHJpbmcocy5uYW1lKSAhPSAncGF5YWJsZScpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZVN0YXRlbWVudHMoX2NsYXNzOiBDbGFzc0RlY2xhcmF0aW9uKTogc3RyaW5nW10ge1xuICByZXR1cm4gX2NsYXNzLm1lbWJlcnNcbiAgICAuZmlsdGVyKGlzRW5jb2RhYmxlKVxuICAgIC5tYXAoKGZpZWxkOiBGaWVsZERlY2xhcmF0aW9uKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0b1N0cmluZyhmaWVsZC5uYW1lKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZURlY29kZVN0YXRlbWVudChmaWVsZCwgYHRoaXMuJHtuYW1lfSA9IG9iai5oYXMoXCIke25hbWV9XCIpID8gYCkgK1xuICAgICAgICBgOiAke1xuICAgICAgICAgIGZpZWxkLmluaXRpYWxpemVyICE9IG51bGxcbiAgICAgICAgICAgID8gdG9TdHJpbmcoZmllbGQuaW5pdGlhbGl6ZXIpXG4gICAgICAgICAgICA6IGB0aGlzLiR7bmFtZX1gXG4gICAgICAgIH07YFxuICAgICAgKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHRyRGVjb2RlU3RhdGVtZW50KFxuICBmaWVsZDogRmllbGREZWNsYXJhdGlvbiB8IFBhcmFtZXRlck5vZGUsXG4gIHNldHRlclByZWZpeCA9ICcnXG4pOiBzdHJpbmcge1xuICBsZXQgVCA9IHRvU3RyaW5nKGZpZWxkLnR5cGUhKTtcbiAgbGV0IG5hbWUgPSB0b1N0cmluZyhmaWVsZC5uYW1lKTtcbiAgcmV0dXJuIGAke3NldHRlclByZWZpeH1yZWFkUmVnaW9uPCR7VH0+KCR7bmFtZX0pYDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlU3RhdGVtZW50KFxuICBmaWVsZDogRmllbGREZWNsYXJhdGlvbiB8IFBhcmFtZXRlck5vZGUsXG4gIHNldHRlclByZWZpeCA9ICcnXG4pOiBzdHJpbmcge1xuICBsZXQgVCA9IHRvU3RyaW5nKGZpZWxkLnR5cGUhKTtcbiAgbGV0IG5hbWUgPSB0b1N0cmluZyhmaWVsZC5uYW1lKTtcbiAgcmV0dXJuIGAke3NldHRlclByZWZpeH1kZWNvZGU8JHtUfSwgSlNPTi5PYmo+KG9iaiwgXCIke25hbWV9XCIpYDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlU3RhdGVtZW50cyhfY2xhc3M6IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBfY2xhc3MubWVtYmVyc1xuICAgIC5maWx0ZXIoaXNFbmNvZGFibGUpXG4gICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IFQgPSB0b1N0cmluZyhmaWVsZC50eXBlISk7XG4gICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKGZpZWxkLm5hbWUpO1xuICAgICAgcmV0dXJuIGBlbmNvZGU8JHtUfSwgSlNPTkVuY29kZXI+KHRoaXMuJHtuYW1lfSwgXCIke25hbWV9XCIsIGVuY29kZXIpO2A7XG4gICAgfSk7XG59XG5cbi8vIFRPRE86IEV4dHJhY3QgdGhpcyBpbnRvIHNlcGFyYXRlIG1vZHVsZSwgcHJlZmVycmFibGUgcGx1Z2dhYmxlXG5leHBvcnQgY2xhc3MgSlNPTkJpbmRpbmdzQnVpbGRlciBleHRlbmRzIEJhc2VWaXNpdG9yIHtcbiAgcHJpdmF0ZSBzYjogc3RyaW5nW10gPSBbXTtcbiAgcHJpdmF0ZSBleHBvcnRlZENsYXNzZXM6IE1hcDxzdHJpbmcsIENsYXNzRGVjbGFyYXRpb24+ID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgaXNUZXN0ID0gZmFsc2U7XG4gIHdyYXBwZWRGdW5jczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgc3RhdGljIGJ1aWxkKHNvdXJjZTogU291cmNlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbmV3IEpTT05CaW5kaW5nc0J1aWxkZXIoKS5idWlsZChzb3VyY2UpO1xuICB9XG5cbiAgc3RhdGljIGlkZW5hRmlsZXMoc291cmNlczogU291cmNlW10pOiBTb3VyY2VbXSB7XG4gICAgcmV0dXJuIHNvdXJjZXMuZmlsdGVyKGhhc0lkZW5hRGVjb3JhdG9yKTtcbiAgfVxuXG4gIHN0YXRpYyBjaGVja1Rlc3RCdWlsZChzb3VyY2VzOiBTb3VyY2VbXSkge1xuICAgIHRoaXMuaXNUZXN0ID0gc291cmNlcy5zb21lKChzKSA9PiBzLm5vcm1hbGl6ZWRQYXRoLmluY2x1ZGVzKCcuc3BlYy4nKSk7XG4gIH1cblxuICB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5leHBvcnRlZENsYXNzZXMuaGFzKHRvU3RyaW5nKG5vZGUubmFtZSkpKSB7XG4gICAgICB0aGlzLmV4cG9ydGVkQ2xhc3Nlcy5zZXQodG9TdHJpbmcobm9kZS5uYW1lKSwgbm9kZSk7XG4gICAgfVxuICAgIHN1cGVyLnZpc2l0Q2xhc3NEZWNsYXJhdGlvbihub2RlKTtcbiAgfVxuXG4gIG5lZWRzV3JhcHBlcihub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gICAgbGV0IGlzRXhwb3J0ID0gbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpO1xuICAgIGxldCBhbHJlYWR5V3JhcHBlZCA9IHRoaXMud3JhcHBlZEZ1bmNzLmhhcyh0b1N0cmluZyhub2RlLm5hbWUpKTtcbiAgICBsZXQgbm9JbnB1dE9yT3V0cHV0ID0gbnVtT2ZQYXJhbWV0ZXJzKG5vZGUpID09IDAgJiYgcmV0dXJuc1ZvaWQobm9kZSk7XG4gICAgbGV0IGlzSWdub3JlID0gdXRpbHMuaGFzRGVjb3JhdG9yKG5vZGUsIElERU5BX0lHTk9SRV9GVU5DX0RFQ09SQVRPUik7XG4gICAgaWYgKFxuICAgICAgaXNJZ25vcmUgfHxcbiAgICAgICFpc0V4cG9ydCB8fFxuICAgICAgYWxyZWFkeVdyYXBwZWQgfHxcbiAgICAgIG5vSW5wdXRPck91dHB1dCB8fFxuICAgICAgSlNPTkJpbmRpbmdzQnVpbGRlci5pc1Rlc3RcbiAgICApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGlzRW50cnkobm9kZSkgfHwgdXRpbHMuaGFzRGVjb3JhdG9yKG5vZGUsIElERU5BX0RFQ09SQVRPUik7XG4gIH1cblxuICB2aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5uZWVkc1dyYXBwZXIobm9kZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGlzRW50cnkobm9kZSkgfHwgdXRpbHMuaGFzRGVjb3JhdG9yKG5vZGUsIElERU5BX0RFQ09SQVRPUikpICYmXG4gICAgICAgICF0aGlzLndyYXBwZWRGdW5jcy5oYXModG9TdHJpbmcobm9kZS5uYW1lKSkgJiZcbiAgICAgICAgbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5zYi5wdXNoKHRoaXMuY2FtZWxDYXNlVG9TbmFrZUNhc2VFeHBvcnQodG9TdHJpbmcobm9kZS5uYW1lKSwgJycpKTtcbiAgICAgICAgdGhpcy53cmFwcGVkRnVuY3MuYWRkKHRvU3RyaW5nKG5vZGUubmFtZSkpO1xuICAgICAgfVxuICAgICAgc3VwZXIudmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyYXRlV3JhcHBlckZ1bmN0aW9uKG5vZGUpO1xuICAgIC8vIENoYW5nZSBmdW5jdGlvbiB0byBub3QgYmUgYW4gZXhwb3J0XG4gICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgXiBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgdGhpcy53cmFwcGVkRnVuY3MuYWRkKHRvU3RyaW5nKG5vZGUubmFtZSkpO1xuICAgIHN1cGVyLnZpc2l0KG5vZGUpO1xuICB9XG5cbiAgY2FtZWxDYXNlVG9TbmFrZUNhc2VFeHBvcnQoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHByZWZpeDogc3RyaW5nID0gV1JBUFBFUl9QUkVGSVhcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgcyA9IG1ha2VTbmFrZUNhc2UobmFtZSk7XG4gICAgaWYgKHMubm9ybWFsaXplKCkgPT09IG5hbWUubm9ybWFsaXplKCkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGBleHBvcnQgeyAke3ByZWZpeCArIG5hbWV9IGFzICR7c30gfWA7XG4gIH1cblxuICAvKlxuICBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleHBvcnQgaW4gdGhlIGZ1bmN0aW9uJ3MgcGxhY2UuXG4gICovXG4gIHByaXZhdGUgZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24oZnVuYzogRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgIGxldCBzaWduYXR1cmUgPSBmdW5jLnNpZ25hdHVyZTtcbiAgICBsZXQgcGFyYW1zID0gc2lnbmF0dXJlLnBhcmFtZXRlcnM7XG4gICAgbGV0IHJldHVyblR5cGUgPSBzaWduYXR1cmUucmV0dXJuVHlwZTtcbiAgICBsZXQgcmV0dXJuVHlwZU5hbWUgPSB0b1N0cmluZyhyZXR1cm5UeXBlKVxuICAgICAgLnNwbGl0KCd8JylcbiAgICAgIC5tYXAoKG5hbWUpID0+IG5hbWUudHJpbSgpKVxuICAgICAgLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gJ251bGwnKVxuICAgICAgLmpvaW4oJ3wnKTtcbiAgICBsZXQgaGFzTnVsbCA9IHRvU3RyaW5nKHJldHVyblR5cGUpLmluY2x1ZGVzKCdudWxsJyk7XG4gICAgbGV0IG5hbWUgPSBmdW5jLm5hbWUudGV4dDtcbiAgICBpZiAoZnVuYy5kZWNvcmF0b3JzICYmIGZ1bmMuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNiLnB1c2goXG4gICAgICAgIGZ1bmMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gdG9TdHJpbmcoZGVjb3JhdG9yKSkuam9pbignXFxuJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHB0clBhcmFtc1NiID0gcGFyYW1zXG4gICAgICAubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKHBhcmFtLm5hbWUpO1xuICAgICAgICByZXR1cm4gYCR7bmFtZX0gOiB1MzJgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcsICcpO1xuXG4gICAgdmFyIHdyYXBwZWRSZXR1cm5UeXBlID0gJ3ZvaWQnO1xuICAgIGlmICh0b1N0cmluZyhyZXR1cm5UeXBlKSAhPT0gJ3ZvaWQnKSB7XG4gICAgICB3cmFwcGVkUmV0dXJuVHlwZSA9ICd1c2l6ZSc7XG4gICAgfVxuXG4gICAgdGhpcy5zYi5wdXNoKFxuICAgICAgYGZ1bmN0aW9uIF9fd3JhcHBlcl8ke25hbWV9KCR7cHRyUGFyYW1zU2J9KTogJHt3cmFwcGVkUmV0dXJuVHlwZX0ge2BcbiAgICApO1xuICAgIGlmICh0b1N0cmluZyhyZXR1cm5UeXBlKSAhPT0gJ3ZvaWQnKSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgbGV0IHJlc3VsdDogJHt0b1N0cmluZyhyZXR1cm5UeXBlKX0gPSAke25hbWV9KGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgJHtuYW1lfShgKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNiW3RoaXMuc2IubGVuZ3RoIC0gMV0gKz0gcGFyYW1zXG4gICAgICAgIC5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICAgICAgbGV0IG5hbWUgPSB0b1N0cmluZyhwYXJhbS5uYW1lKTtcbiAgICAgICAgICBsZXQgdHlwZSA9IHRvU3RyaW5nKHBhcmFtLnR5cGUpO1xuICAgICAgICAgIGxldCByZXMgPSBgJHtuYW1lfT4wID8gJHtjcmVhdGVQdHJEZWNvZGVTdGF0ZW1lbnQocGFyYW0pfSA6ICR7XG4gICAgICAgICAgICBwYXJhbS5pbml0aWFsaXplclxuICAgICAgICAgICAgICA/IHRvU3RyaW5nKHBhcmFtLmluaXRpYWxpemVyKVxuICAgICAgICAgICAgICA6IGByZXF1aXJlUGFyYW1ldGVyPCR7dHlwZX0+KFwiJHtuYW1lfVwiKWBcbiAgICAgICAgICB9YDtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLFxcbiAgICAnKTtcbiAgICB9XG4gICAgdGhpcy5zYlt0aGlzLnNiLmxlbmd0aCAtIDFdICs9ICcpOyc7XG4gICAgaWYgKHRvU3RyaW5nKHJldHVyblR5cGUpICE9PSAndm9pZCcpIHtcbiAgICAgIHRoaXMuc2IucHVzaChgXG4gICAgICByZXR1cm4gd3JpdGVfcmVnaW9uPCR7dG9TdHJpbmcocmV0dXJuVHlwZSl9PihyZXN1bHQpO2ApO1xuICAgIH1cbiAgICB0aGlzLnNiLnB1c2goYH1cbmV4cG9ydCB7ICR7V1JBUFBFUl9QUkVGSVggKyBuYW1lfSBhcyAke25hbWV9IH1cbiR7dGhpcy5jYW1lbENhc2VUb1NuYWtlQ2FzZUV4cG9ydChuYW1lKX1cbmApO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBlTmFtZSh0eXBlOiBUeXBlTm9kZSB8IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmcge1xuICAgIGlmICghaXNDbGFzcyh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHR5cGUpO1xuICAgIH1cbiAgICB0eXBlID0gPENsYXNzRGVjbGFyYXRpb24+dHlwZTtcbiAgICBsZXQgY2xhc3NOYW1lID0gdG9TdHJpbmcodHlwZS5uYW1lKTtcbiAgICBpZiAodHlwZS5pc0dlbmVyaWMpIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnPCcgKyB0eXBlLnR5cGVQYXJhbWV0ZXJzIS5tYXAodG9TdHJpbmcpLmpvaW4oJywgJykgKyAnPic7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBidWlsZChzb3VyY2U6IFNvdXJjZSk6IHN0cmluZyB7XG4gICAgdGhpcy5zYiA9IFtdO1xuICAgIHRoaXMudmlzaXQoc291cmNlKTtcblxuICAgIGxldCBzb3VyY2VUZXh0ID0gc291cmNlLnN0YXRlbWVudHMubWFwKChzdG10KSA9PiB7XG4gICAgICBsZXQgc3RyO1xuXG4gICAgICBpZiAoaXNDbGFzcyhzdG10KSkge1xuICAgICAgICBsZXQgX2NsYXNzID0gPENsYXNzRGVjbGFyYXRpb24+c3RtdDtcbiAgICAgICAgbGV0IGlzSWdub3JlID0gdXRpbHMuaGFzRGVjb3JhdG9yKF9jbGFzcywgSURFTkFfSUdOT1JFX0ZVTkNfREVDT1JBVE9SKTtcbiAgICAgICAgaWYgKCFpc0lnbm9yZSkge1xuICAgICAgICAgIGxldCBmaWVsZHMgPSBfY2xhc3MubWVtYmVyc1xuICAgICAgICAgICAgLmZpbHRlcihpc0ZpZWxkKVxuICAgICAgICAgICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pID0+IGZpZWxkKTtcbiAgICAgICAgICBpZiAoZmllbGRzLnNvbWUoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBGaWVsZHMgbXVzdCBoYXZlIGV4cGxpY2l0IHR5cGUgZGVjbGFyYXRpb24uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmluaXRpYWxpemVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgZmllbGQuaW5pdGlhbGl6ZXIgPSBTaW1wbGVQYXJzZXIucGFyc2VFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgIGBkZWZhdWx0VmFsdWU8JHt0b1N0cmluZyhmaWVsZC50eXBlISl9PigpKWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdHIgPSB0b1N0cmluZyhzdG10KTtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgc3RyLmxhc3RJbmRleE9mKCd9JykpO1xuICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLnR5cGVOYW1lKF9jbGFzcyk7XG4gICAgICAgICAgc3RyICs9IGBcbiAgZGVjb2RlPF9WID0gVWludDhBcnJheT4oYnVmOiBfVik6ICR7Y2xhc3NOYW1lfSB7XG4gICAgbGV0IGpzb246IEpTT04uT2JqO1xuICAgIGlmIChidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShidWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoYnVmIGluc3RhbmNlb2YgSlNPTi5PYmosIFwiYXJndW1lbnQgbXVzdCBiZSBVaW50OEFycmF5IG9yIEpzb24gT2JqZWN0XCIpO1xuICAgICAganNvbiA9IDxKU09OLk9iaj4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGpzb24pO1xuICB9XG5cbiAgc3RhdGljIGRlY29kZShidWY6IFVpbnQ4QXJyYXkpOiAke2NsYXNzTmFtZX0ge1xuICAgIHJldHVybiBkZWNvZGU8JHtjbGFzc05hbWV9PihidWYpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVjb2RlKG9iajogSlNPTi5PYmopOiAke2NsYXNzTmFtZX0ge1xuICAgICR7Y3JlYXRlRGVjb2RlU3RhdGVtZW50cyhfY2xhc3MpLmpvaW4oJ1xcbiAgICAnKX0gICAgXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfZW5jb2RlKG5hbWU6IHN0cmluZyB8IG51bGwgPSBcIlwiLCBfZW5jb2RlcjogSlNPTkVuY29kZXIgfCBudWxsID0gbnVsbCk6IEpTT05FbmNvZGVyIHtcbiAgICBsZXQgZW5jb2RlciA9IF9lbmNvZGVyID09IG51bGwgPyBuZXcgSlNPTkVuY29kZXIoKSA6IF9lbmNvZGVyO1xuICAgIGVuY29kZXIucHVzaE9iamVjdChuYW1lKTtcbiAgICAke2NyZWF0ZUVuY29kZVN0YXRlbWVudHMoX2NsYXNzKS5qb2luKCdcXG4gICAgJyl9XG4gICAgZW5jb2Rlci5wb3BPYmplY3QoKTtcbiAgICByZXR1cm4gZW5jb2RlcjtcbiAgfVxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZSgpLnNlcmlhbGl6ZSgpO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZSgpO1xuICB9XG5cbiAgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZSgpLnRvU3RyaW5nKCk7XG4gIH1cbn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHRvU3RyaW5nKHN0bXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdG10KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvdXJjZVRleHQuY29uY2F0KHRoaXMuc2IpLmpvaW4oJ1xcbicpO1xuICB9XG59XG4iXX0=