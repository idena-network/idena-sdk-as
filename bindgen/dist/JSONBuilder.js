"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONBindingsBuilder = exports.isEntry = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const utils_1 = require("./utils");
const IDENA_DECORATOR = 'idenaBindgen';
const IDENA_IGNORE_FUNC_DECORATOR = 'idenaBindgenIgnore';
const WRAPPER_PREFIX = '__wrapper_';
function returnsVoid(node) {
    return (0, utils_1.toString)(node.signature.returnType) === 'void';
}
function numOfParameters(node) {
    return node.signature.parameters.length;
}
function hasIdenaDecorator(stmt) {
    return (isEntry(stmt) ||
        stmt.statements.some((s) => s instanceof as_1.DeclarationStatement &&
            visitor_as_1.utils.hasDecorator(s, IDENA_DECORATOR)));
}
function isEntry(source) {
    return source.range.source.sourceKind == as_1.SourceKind.USER_ENTRY;
}
exports.isEntry = isEntry;
function isClass(type) {
    return type.kind == as_1.NodeKind.CLASSDECLARATION;
}
function isField(mem) {
    return mem.kind == as_1.NodeKind.FIELDDECLARATION;
}
function isStatic(mem) {
    return mem.is(as_1.CommonFlags.STATIC);
}
function isEncodable(mem) {
    return isField(mem) && !isStatic(mem);
}
function isPayable(func) {
    return (func.decorators != null &&
        func.decorators.some((s) => (0, utils_1.toString)(s.name) != 'payable'));
}
function createDecodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        const name = (0, utils_1.toString)(field.name);
        return (createDecodeStatement(field, `this.${name} = obj.has("${name}") ? `) +
            `: ${field.initializer != null
                ? (0, utils_1.toString)(field.initializer)
                : `this.${name}`};`);
    });
}
function createPtrDecodeStatement(field, setterPrefix = '') {
    let T = (0, utils_1.toString)(field.type);
    let name = (0, utils_1.toString)(field.name);
    return `${setterPrefix}readRegion<${T}>(${name})`;
}
function createDecodeStatement(field, setterPrefix = "") {
    let T = (0, utils_1.toString)(field.type);
    let name = (0, utils_1.toString)(field.name);
    return `${setterPrefix}decode<${T}, JSON.Obj>(obj, "${name}")`;
}
function createEncodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        let T = (0, utils_1.toString)(field.type);
        let name = (0, utils_1.toString)(field.name);
        return `encode<${T}, JSONEncoder>(this.${name}, "${name}", encoder);`;
    });
}
// TODO: Extract this into separate module, preferrable pluggable
class JSONBindingsBuilder extends visitor_as_1.BaseVisitor {
    sb = [];
    exportedClasses = new Map();
    static isTest = false;
    wrappedFuncs = new Set();
    static build(source) {
        return new JSONBindingsBuilder().build(source);
    }
    static idenaFiles(sources) {
        return sources.filter(hasIdenaDecorator);
    }
    static checkTestBuild(sources) {
        this.isTest = sources.some((s) => s.normalizedPath.includes('.spec.'));
    }
    visitClassDeclaration(node) {
        if (!this.exportedClasses.has((0, utils_1.toString)(node.name))) {
            this.exportedClasses.set((0, utils_1.toString)(node.name), node);
        }
        super.visitClassDeclaration(node);
    }
    needsWrapper(node) {
        let isExport = node.is(as_1.CommonFlags.EXPORT);
        let alreadyWrapped = this.wrappedFuncs.has((0, utils_1.toString)(node.name));
        let noInputOrOutput = numOfParameters(node) == 0 && returnsVoid(node);
        let isIgnore = visitor_as_1.utils.hasDecorator(node, IDENA_IGNORE_FUNC_DECORATOR);
        if (isIgnore ||
            !isExport ||
            alreadyWrapped ||
            noInputOrOutput ||
            JSONBindingsBuilder.isTest)
            return false;
        return isEntry(node) || visitor_as_1.utils.hasDecorator(node, IDENA_DECORATOR);
    }
    visitFunctionDeclaration(node) {
        if (!this.needsWrapper(node)) {
            if ((isEntry(node) || visitor_as_1.utils.hasDecorator(node, IDENA_DECORATOR)) &&
                !this.wrappedFuncs.has((0, utils_1.toString)(node.name)) &&
                node.is(as_1.CommonFlags.EXPORT)) {
                this.sb.push(this.camelCaseToSnakeCaseExport((0, utils_1.toString)(node.name), ''));
                this.wrappedFuncs.add((0, utils_1.toString)(node.name));
            }
            super.visitFunctionDeclaration(node);
            return;
        }
        this.generateWrapperFunction(node);
        // Change function to not be an export
        node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add((0, utils_1.toString)(node.name));
        super.visit(node);
    }
    camelCaseToSnakeCaseExport(name, prefix = WRAPPER_PREFIX) {
        let s = (0, utils_1.makeSnakeCase)(name);
        if (s.normalize() === name.normalize()) {
            return '';
        }
        return `export { ${prefix + name} as ${s} }`;
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = (0, utils_1.toString)(returnType)
            .split('|')
            .map((name) => name.trim())
            .filter((name) => name !== 'null')
            .join('|');
        let hasNull = (0, utils_1.toString)(returnType).includes('null');
        let name = func.name.text;
        if (func.decorators && func.decorators.length > 0) {
            this.sb.push(func.decorators.map((decorator) => (0, utils_1.toString)(decorator)).join('\n'));
        }
        var ptrParamsSb = params
            .map((param) => {
            let name = (0, utils_1.toString)(param.name);
            return `${name} : u32`;
        })
            .join(', ');
        var wrappedReturnType = "void";
        if ((0, utils_1.toString)(returnType) !== 'void') {
            wrappedReturnType = "usize";
        }
        this.sb.push(`function __wrapper_${name}(${ptrParamsSb}): ${wrappedReturnType} {`);
        if ((0, utils_1.toString)(returnType) !== 'void') {
            this.sb.push(`  let result: ${(0, utils_1.toString)(returnType)} = ${name}(`);
        }
        else {
            this.sb.push(`  ${name}(`);
        }
        if (params.length > 0) {
            this.sb[this.sb.length - 1] += params
                .map((param) => {
                let name = (0, utils_1.toString)(param.name);
                let type = (0, utils_1.toString)(param.type);
                let res = `${name}>0 ? ${createPtrDecodeStatement(param)} : ${param.initializer
                    ? (0, utils_1.toString)(param.initializer)
                    : `requireParameter<${type}>("${name}")`}`;
                return res;
            })
                .join(',\n    ');
        }
        this.sb[this.sb.length - 1] += ');';
        if ((0, utils_1.toString)(returnType) !== 'void') {
            this.sb.push(`
      return write_region<${(0, utils_1.toString)(returnType)}>(result);`);
        }
        this.sb.push(`}
export { ${WRAPPER_PREFIX + name} as ${name} }
${this.camelCaseToSnakeCaseExport(name)}
`);
    }
    typeName(type) {
        if (!isClass(type)) {
            return (0, utils_1.toString)(type);
        }
        type = type;
        let className = (0, utils_1.toString)(type.name);
        if (type.isGeneric) {
            className += '<' + type.typeParameters.map(utils_1.toString).join(', ') + '>';
        }
        return className;
    }
    build(source) {
        this.sb = [];
        this.visit(source);
        let sourceText = source.statements.map((stmt) => {
            let str;
            if (isClass(stmt) &&
                visitor_as_1.utils.hasDecorator(stmt, IDENA_DECORATOR)) {
                let _class = stmt;
                let fields = _class.members
                    .filter(isField)
                    .map((field) => field);
                if (fields.some((field) => field.type == null)) {
                    throw new Error('All Fields must have explicit type declaration.');
                }
                fields.forEach((field) => {
                    if (field.initializer == null) {
                        field.initializer = utils_1.SimpleParser.parseExpression(`defaultValue<${(0, utils_1.toString)(field.type)}>())`);
                    }
                });
                str = (0, utils_1.toString)(stmt);
                str = str.slice(0, str.lastIndexOf('}'));
                let className = this.typeName(_class);
                str += `
  decode<_V = Uint8Array>(buf: _V): ${className} {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): ${className} {
    return decode<${className}>(buf);
  }

  private _decode(obj: JSON.Obj): ${className} {
    ${createDecodeStatements(_class).join('\n    ')}    
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    ${createEncodeStatements(_class).join('\n    ')}
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}`;
            }
            else {
                str = (0, utils_1.toString)(stmt);
            }
            return str;
        });
        return sourceText.concat(this.sb).join('\n');
    }
}
exports.JSONBindingsBuilder = JSONBindingsBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTkJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvSlNPTkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0NBWXVCO0FBQ3ZCLDJDQUE4QztBQUM5QyxtQ0FBOEQ7QUFFOUQsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDO0FBQ3ZDLE1BQU0sMkJBQTJCLEdBQUcsb0JBQW9CLENBQUM7QUFDekQsTUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDO0FBRXBDLFNBQVMsV0FBVyxDQUFDLElBQXlCO0lBQzVDLE9BQU8sSUFBQSxnQkFBUSxFQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEtBQUssTUFBTSxDQUFDO0FBQ3hELENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxJQUF5QjtJQUNoRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztBQUMxQyxDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxJQUFZO0lBQ3JDLE9BQU8sQ0FDTCxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ2IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQ2xCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDSixDQUFDLFlBQVkseUJBQW9CO1lBQ2pDLGtCQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsQ0FDekMsQ0FDRixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQWdCLE9BQU8sQ0FBQyxNQUFxQjtJQUMzQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsSUFBSSxlQUFVLENBQUMsVUFBVSxDQUFDO0FBQ2pFLENBQUM7QUFGRCwwQkFFQztBQUVELFNBQVMsT0FBTyxDQUFDLElBQVU7SUFDekIsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJLGFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztBQUNoRCxDQUFDO0FBRUQsU0FBUyxPQUFPLENBQUMsR0FBeUI7SUFD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OlsiaW1wb3J0IHtcbiAgTm9kZSxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgTm9kZUtpbmQsXG4gIFNvdXJjZSxcbiAgU291cmNlS2luZCxcbiAgVHlwZU5vZGUsXG4gIENsYXNzRGVjbGFyYXRpb24sXG4gIERlY2xhcmF0aW9uU3RhdGVtZW50LFxuICBDb21tb25GbGFncyxcbiAgRmllbGREZWNsYXJhdGlvbixcbiAgUGFyYW1ldGVyTm9kZSxcbn0gZnJvbSAndmlzaXRvci1hcy9hcyc7XG5pbXBvcnQge0Jhc2VWaXNpdG9yLCB1dGlsc30gZnJvbSAndmlzaXRvci1hcyc7XG5pbXBvcnQge1NpbXBsZVBhcnNlciwgdG9TdHJpbmcsIG1ha2VTbmFrZUNhc2V9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBJREVOQV9ERUNPUkFUT1IgPSAnaWRlbmFCaW5kZ2VuJztcbmNvbnN0IElERU5BX0lHTk9SRV9GVU5DX0RFQ09SQVRPUiA9ICdpZGVuYUJpbmRnZW5JZ25vcmUnO1xuY29uc3QgV1JBUFBFUl9QUkVGSVggPSAnX193cmFwcGVyXyc7XG5cbmZ1bmN0aW9uIHJldHVybnNWb2lkKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHRvU3RyaW5nKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpID09PSAndm9pZCc7XG59XG5cbmZ1bmN0aW9uIG51bU9mUGFyYW1ldGVycyhub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogbnVtYmVyIHtcbiAgcmV0dXJuIG5vZGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBoYXNJZGVuYURlY29yYXRvcihzdG10OiBTb3VyY2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBpc0VudHJ5KHN0bXQpIHx8XG4gICAgc3RtdC5zdGF0ZW1lbnRzLnNvbWUoXG4gICAgICAocykgPT5cbiAgICAgICAgcyBpbnN0YW5jZW9mIERlY2xhcmF0aW9uU3RhdGVtZW50ICYmXG4gICAgICAgIHV0aWxzLmhhc0RlY29yYXRvcihzLCBJREVOQV9ERUNPUkFUT1IpXG4gICAgKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbnRyeShzb3VyY2U6IFNvdXJjZSB8IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHNvdXJjZS5yYW5nZS5zb3VyY2Uuc291cmNlS2luZCA9PSBTb3VyY2VLaW5kLlVTRVJfRU5UUlk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3ModHlwZTogTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZS5raW5kID09IE5vZGVLaW5kLkNMQVNTREVDTEFSQVRJT047XG59XG5cbmZ1bmN0aW9uIGlzRmllbGQobWVtOiBEZWNsYXJhdGlvblN0YXRlbWVudCkge1xuICByZXR1cm4gbWVtLmtpbmQgPT0gTm9kZUtpbmQuRklFTERERUNMQVJBVElPTjtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMobWVtOiBEZWNsYXJhdGlvblN0YXRlbWVudCkge1xuICByZXR1cm4gbWVtLmlzKENvbW1vbkZsYWdzLlNUQVRJQyk7XG59XG5cbmZ1bmN0aW9uIGlzRW5jb2RhYmxlKG1lbTogRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIGlzRmllbGQobWVtKSAmJiAhaXNTdGF0aWMobWVtKTtcbn1cblxuZnVuY3Rpb24gaXNQYXlhYmxlKGZ1bmM6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBmdW5jLmRlY29yYXRvcnMgIT0gbnVsbCAmJlxuICAgIGZ1bmMuZGVjb3JhdG9ycy5zb21lKChzKSA9PiB0b1N0cmluZyhzLm5hbWUpICE9ICdwYXlhYmxlJylcbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlU3RhdGVtZW50cyhfY2xhc3M6IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBfY2xhc3MubWVtYmVyc1xuICAgIC5maWx0ZXIoaXNFbmNvZGFibGUpXG4gICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHRvU3RyaW5nKGZpZWxkLm5hbWUpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlRGVjb2RlU3RhdGVtZW50KGZpZWxkLCBgdGhpcy4ke25hbWV9ID0gb2JqLmhhcyhcIiR7bmFtZX1cIikgPyBgKSArXG4gICAgICAgIGA6ICR7XG4gICAgICAgICAgZmllbGQuaW5pdGlhbGl6ZXIgIT0gbnVsbFxuICAgICAgICAgICAgPyB0b1N0cmluZyhmaWVsZC5pbml0aWFsaXplcilcbiAgICAgICAgICAgIDogYHRoaXMuJHtuYW1lfWBcbiAgICAgICAgfTtgXG4gICAgICApO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQdHJEZWNvZGVTdGF0ZW1lbnQoXG4gIGZpZWxkOiBGaWVsZERlY2xhcmF0aW9uIHwgUGFyYW1ldGVyTm9kZSxcbiAgc2V0dGVyUHJlZml4ID0gJydcbik6IHN0cmluZyB7XG4gIGxldCBUID0gdG9TdHJpbmcoZmllbGQudHlwZSEpO1xuICBsZXQgbmFtZSA9IHRvU3RyaW5nKGZpZWxkLm5hbWUpO1xuICByZXR1cm4gYCR7c2V0dGVyUHJlZml4fXJlYWRSZWdpb248JHtUfT4oJHtuYW1lfSlgO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVTdGF0ZW1lbnQoXG4gIGZpZWxkOiBGaWVsZERlY2xhcmF0aW9uIHwgUGFyYW1ldGVyTm9kZSxcbiAgc2V0dGVyUHJlZml4ID0gXCJcIlxuKTogc3RyaW5nIHtcbiAgbGV0IFQgPSB0b1N0cmluZyhmaWVsZC50eXBlISk7XG4gIGxldCBuYW1lID0gdG9TdHJpbmcoZmllbGQubmFtZSk7XG4gIHJldHVybiBgJHtzZXR0ZXJQcmVmaXh9ZGVjb2RlPCR7VH0sIEpTT04uT2JqPihvYmosIFwiJHtuYW1lfVwiKWA7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVuY29kZVN0YXRlbWVudHMoX2NsYXNzOiBDbGFzc0RlY2xhcmF0aW9uKTogc3RyaW5nW10ge1xuICByZXR1cm4gX2NsYXNzLm1lbWJlcnNcbiAgICAuZmlsdGVyKGlzRW5jb2RhYmxlKVxuICAgIC5tYXAoKGZpZWxkOiBGaWVsZERlY2xhcmF0aW9uKTogc3RyaW5nID0+IHtcbiAgICAgIGxldCBUID0gdG9TdHJpbmcoZmllbGQudHlwZSEpO1xuICAgICAgbGV0IG5hbWUgPSB0b1N0cmluZyhmaWVsZC5uYW1lKTtcbiAgICAgIHJldHVybiBgZW5jb2RlPCR7VH0sIEpTT05FbmNvZGVyPih0aGlzLiR7bmFtZX0sIFwiJHtuYW1lfVwiLCBlbmNvZGVyKTtgO1xuICAgIH0pO1xufVxuXG4vLyBUT0RPOiBFeHRyYWN0IHRoaXMgaW50byBzZXBhcmF0ZSBtb2R1bGUsIHByZWZlcnJhYmxlIHBsdWdnYWJsZVxuZXhwb3J0IGNsYXNzIEpTT05CaW5kaW5nc0J1aWxkZXIgZXh0ZW5kcyBCYXNlVmlzaXRvciB7XG4gIHByaXZhdGUgc2I6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgZXhwb3J0ZWRDbGFzc2VzOiBNYXA8c3RyaW5nLCBDbGFzc0RlY2xhcmF0aW9uPiA9IG5ldyBNYXAoKTtcbiAgc3RhdGljIGlzVGVzdCA9IGZhbHNlO1xuICB3cmFwcGVkRnVuY3M6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4gIHN0YXRpYyBidWlsZChzb3VyY2U6IFNvdXJjZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5ldyBKU09OQmluZGluZ3NCdWlsZGVyKCkuYnVpbGQoc291cmNlKTtcbiAgfVxuXG4gIHN0YXRpYyBpZGVuYUZpbGVzKHNvdXJjZXM6IFNvdXJjZVtdKTogU291cmNlW10ge1xuICAgIHJldHVybiBzb3VyY2VzLmZpbHRlcihoYXNJZGVuYURlY29yYXRvcik7XG4gIH1cblxuICBzdGF0aWMgY2hlY2tUZXN0QnVpbGQoc291cmNlczogU291cmNlW10pIHtcbiAgICB0aGlzLmlzVGVzdCA9IHNvdXJjZXMuc29tZSgocykgPT4gcy5ub3JtYWxpemVkUGF0aC5pbmNsdWRlcygnLnNwZWMuJykpO1xuICB9XG5cbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZXhwb3J0ZWRDbGFzc2VzLmhhcyh0b1N0cmluZyhub2RlLm5hbWUpKSkge1xuICAgICAgdGhpcy5leHBvcnRlZENsYXNzZXMuc2V0KHRvU3RyaW5nKG5vZGUubmFtZSksIG5vZGUpO1xuICAgIH1cbiAgICBzdXBlci52aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZSk7XG4gIH1cblxuICBuZWVkc1dyYXBwZXIobm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICAgIGxldCBpc0V4cG9ydCA9IG5vZGUuaXMoQ29tbW9uRmxhZ3MuRVhQT1JUKTtcbiAgICBsZXQgYWxyZWFkeVdyYXBwZWQgPSB0aGlzLndyYXBwZWRGdW5jcy5oYXModG9TdHJpbmcobm9kZS5uYW1lKSk7XG4gICAgbGV0IG5vSW5wdXRPck91dHB1dCA9IG51bU9mUGFyYW1ldGVycyhub2RlKSA9PSAwICYmIHJldHVybnNWb2lkKG5vZGUpO1xuICAgIGxldCBpc0lnbm9yZSAgPSB1dGlscy5oYXNEZWNvcmF0b3Iobm9kZSwgSURFTkFfSUdOT1JFX0ZVTkNfREVDT1JBVE9SKTsgIFxuICAgIGlmIChcbiAgICAgIGlzSWdub3JlIHx8XG4gICAgICAhaXNFeHBvcnQgfHxcbiAgICAgIGFscmVhZHlXcmFwcGVkIHx8XG4gICAgICBub0lucHV0T3JPdXRwdXQgfHxcbiAgICAgIEpTT05CaW5kaW5nc0J1aWxkZXIuaXNUZXN0XG4gICAgKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBpc0VudHJ5KG5vZGUpIHx8IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBJREVOQV9ERUNPUkFUT1IpO1xuICB9XG5cbiAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubmVlZHNXcmFwcGVyKG5vZGUpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChpc0VudHJ5KG5vZGUpIHx8IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBJREVOQV9ERUNPUkFUT1IpKSAmJlxuICAgICAgICAhdGhpcy53cmFwcGVkRnVuY3MuaGFzKHRvU3RyaW5nKG5vZGUubmFtZSkpICYmXG4gICAgICAgIG5vZGUuaXMoQ29tbW9uRmxhZ3MuRVhQT1JUKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuc2IucHVzaCh0aGlzLmNhbWVsQ2FzZVRvU25ha2VDYXNlRXhwb3J0KHRvU3RyaW5nKG5vZGUubmFtZSksICcnKSk7XG4gICAgICAgIHRoaXMud3JhcHBlZEZ1bmNzLmFkZCh0b1N0cmluZyhub2RlLm5hbWUpKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnZpc2l0RnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZVdyYXBwZXJGdW5jdGlvbihub2RlKTtcbiAgICAvLyBDaGFuZ2UgZnVuY3Rpb24gdG8gbm90IGJlIGFuIGV4cG9ydFxuICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzIF4gQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgIHRoaXMud3JhcHBlZEZ1bmNzLmFkZCh0b1N0cmluZyhub2RlLm5hbWUpKTtcbiAgICBzdXBlci52aXNpdChub2RlKTtcbiAgfVxuXG4gIGNhbWVsQ2FzZVRvU25ha2VDYXNlRXhwb3J0KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBwcmVmaXg6IHN0cmluZyA9IFdSQVBQRVJfUFJFRklYXG4gICk6IHN0cmluZyB7XG4gICAgbGV0IHMgPSBtYWtlU25ha2VDYXNlKG5hbWUpO1xuICAgIGlmIChzLm5vcm1hbGl6ZSgpID09PSBuYW1lLm5vcm1hbGl6ZSgpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBgZXhwb3J0IHsgJHtwcmVmaXggKyBuYW1lfSBhcyAke3N9IH1gO1xuICB9XG5cbiAgLypcbiAgQ3JlYXRlIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhwb3J0IGluIHRoZSBmdW5jdGlvbidzIHBsYWNlLlxuICAqL1xuICBwcml2YXRlIGdlbmVyYXRlV3JhcHBlckZ1bmN0aW9uKGZ1bmM6IEZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICBsZXQgc2lnbmF0dXJlID0gZnVuYy5zaWduYXR1cmU7XG4gICAgbGV0IHBhcmFtcyA9IHNpZ25hdHVyZS5wYXJhbWV0ZXJzO1xuICAgIGxldCByZXR1cm5UeXBlID0gc2lnbmF0dXJlLnJldHVyblR5cGU7XG4gICAgbGV0IHJldHVyblR5cGVOYW1lID0gdG9TdHJpbmcocmV0dXJuVHlwZSlcbiAgICAgIC5zcGxpdCgnfCcpXG4gICAgICAubWFwKChuYW1lKSA9PiBuYW1lLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09ICdudWxsJylcbiAgICAgIC5qb2luKCd8Jyk7XG4gICAgbGV0IGhhc051bGwgPSB0b1N0cmluZyhyZXR1cm5UeXBlKS5pbmNsdWRlcygnbnVsbCcpO1xuICAgIGxldCBuYW1lID0gZnVuYy5uYW1lLnRleHQ7XG4gICAgaWYgKGZ1bmMuZGVjb3JhdG9ycyAmJiBmdW5jLmRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zYi5wdXNoKFxuICAgICAgICBmdW5jLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IHRvU3RyaW5nKGRlY29yYXRvcikpLmpvaW4oJ1xcbicpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBwdHJQYXJhbXNTYiA9IHBhcmFtc1xuICAgICAgLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgbGV0IG5hbWUgPSB0b1N0cmluZyhwYXJhbS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9IDogdTMyYDtcbiAgICAgIH0pXG4gICAgICAuam9pbignLCAnKTtcblxuICAgIHZhciB3cmFwcGVkUmV0dXJuVHlwZSA9IFwidm9pZFwiO1xuICAgIGlmICh0b1N0cmluZyhyZXR1cm5UeXBlKSAhPT0gJ3ZvaWQnKSB7XG4gICAgICB3cmFwcGVkUmV0dXJuVHlwZSAgPSBcInVzaXplXCI7XG4gICAgfVxuXG4gICAgdGhpcy5zYi5wdXNoKGBmdW5jdGlvbiBfX3dyYXBwZXJfJHtuYW1lfSgke3B0clBhcmFtc1NifSk6ICR7d3JhcHBlZFJldHVyblR5cGV9IHtgKTsgICAgXG4gICAgaWYgKHRvU3RyaW5nKHJldHVyblR5cGUpICE9PSAndm9pZCcpIHtcbiAgICAgIHRoaXMuc2IucHVzaChgICBsZXQgcmVzdWx0OiAke3RvU3RyaW5nKHJldHVyblR5cGUpfSA9ICR7bmFtZX0oYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2IucHVzaChgICAke25hbWV9KGApO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2JbdGhpcy5zYi5sZW5ndGggLSAxXSArPSBwYXJhbXNcbiAgICAgICAgLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKHBhcmFtLm5hbWUpO1xuICAgICAgICAgIGxldCB0eXBlID0gdG9TdHJpbmcocGFyYW0udHlwZSk7XG4gICAgICAgICAgbGV0IHJlcyA9IGAke25hbWV9PjAgPyAke2NyZWF0ZVB0ckRlY29kZVN0YXRlbWVudChwYXJhbSl9IDogJHtcbiAgICAgICAgICAgIHBhcmFtLmluaXRpYWxpemVyXG4gICAgICAgICAgICAgID8gdG9TdHJpbmcocGFyYW0uaW5pdGlhbGl6ZXIpXG4gICAgICAgICAgICAgIDogYHJlcXVpcmVQYXJhbWV0ZXI8JHt0eXBlfT4oXCIke25hbWV9XCIpYFxuICAgICAgICAgIH1gO1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsXFxuICAgICcpO1xuICAgIH1cbiAgICB0aGlzLnNiW3RoaXMuc2IubGVuZ3RoIC0gMV0gKz0gJyk7JztcbiAgICBpZiAodG9TdHJpbmcocmV0dXJuVHlwZSkgIT09ICd2b2lkJykge1xuICAgICAgdGhpcy5zYi5wdXNoKGBcbiAgICAgIHJldHVybiB3cml0ZV9yZWdpb248JHt0b1N0cmluZyhyZXR1cm5UeXBlKX0+KHJlc3VsdCk7YCk7XG4gICAgfVxuICAgIHRoaXMuc2IucHVzaChgfVxuZXhwb3J0IHsgJHtXUkFQUEVSX1BSRUZJWCArIG5hbWV9IGFzICR7bmFtZX0gfVxuJHt0aGlzLmNhbWVsQ2FzZVRvU25ha2VDYXNlRXhwb3J0KG5hbWUpfVxuYCk7XG4gIH1cblxuICBwcml2YXRlIHR5cGVOYW1lKHR5cGU6IFR5cGVOb2RlIHwgQ2xhc3NEZWNsYXJhdGlvbik6IHN0cmluZyB7XG4gICAgaWYgKCFpc0NsYXNzKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodHlwZSk7XG4gICAgfVxuICAgIHR5cGUgPSA8Q2xhc3NEZWNsYXJhdGlvbj50eXBlO1xuICAgIGxldCBjbGFzc05hbWUgPSB0b1N0cmluZyh0eXBlLm5hbWUpO1xuICAgIGlmICh0eXBlLmlzR2VuZXJpYykge1xuICAgICAgY2xhc3NOYW1lICs9ICc8JyArIHR5cGUudHlwZVBhcmFtZXRlcnMhLm1hcCh0b1N0cmluZykuam9pbignLCAnKSArICc+JztcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIGJ1aWxkKHNvdXJjZTogU291cmNlKTogc3RyaW5nIHtcbiAgICB0aGlzLnNiID0gW107XG4gICAgdGhpcy52aXNpdChzb3VyY2UpO1xuXG4gICAgbGV0IHNvdXJjZVRleHQgPSBzb3VyY2Uuc3RhdGVtZW50cy5tYXAoKHN0bXQpID0+IHtcbiAgICAgIGxldCBzdHI7XG4gICAgICBpZiAoXG4gICAgICAgIGlzQ2xhc3Moc3RtdCkgJiZcbiAgICAgICAgdXRpbHMuaGFzRGVjb3JhdG9yKDxDbGFzc0RlY2xhcmF0aW9uPnN0bXQsIElERU5BX0RFQ09SQVRPUilcbiAgICAgICkge1xuICAgICAgICBsZXQgX2NsYXNzID0gPENsYXNzRGVjbGFyYXRpb24+c3RtdDtcbiAgICAgICAgbGV0IGZpZWxkcyA9IF9jbGFzcy5tZW1iZXJzXG4gICAgICAgICAgLmZpbHRlcihpc0ZpZWxkKVxuICAgICAgICAgIC5tYXAoKGZpZWxkOiBGaWVsZERlY2xhcmF0aW9uKSA9PiBmaWVsZCk7XG4gICAgICAgIGlmIChmaWVsZHMuc29tZSgoZmllbGQpID0+IGZpZWxkLnR5cGUgPT0gbnVsbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBGaWVsZHMgbXVzdCBoYXZlIGV4cGxpY2l0IHR5cGUgZGVjbGFyYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGZpZWxkLmluaXRpYWxpemVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpZWxkLmluaXRpYWxpemVyID0gU2ltcGxlUGFyc2VyLnBhcnNlRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgYGRlZmF1bHRWYWx1ZTwke3RvU3RyaW5nKGZpZWxkLnR5cGUhKX0+KCkpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdG10KTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIHN0ci5sYXN0SW5kZXhPZignfScpKTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMudHlwZU5hbWUoX2NsYXNzKTtcbiAgICAgICAgc3RyICs9IGBcbiAgZGVjb2RlPF9WID0gVWludDhBcnJheT4oYnVmOiBfVik6ICR7Y2xhc3NOYW1lfSB7XG4gICAgbGV0IGpzb246IEpTT04uT2JqO1xuICAgIGlmIChidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShidWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoYnVmIGluc3RhbmNlb2YgSlNPTi5PYmosIFwiYXJndW1lbnQgbXVzdCBiZSBVaW50OEFycmF5IG9yIEpzb24gT2JqZWN0XCIpO1xuICAgICAganNvbiA9IDxKU09OLk9iaj4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGpzb24pO1xuICB9XG5cbiAgc3RhdGljIGRlY29kZShidWY6IFVpbnQ4QXJyYXkpOiAke2NsYXNzTmFtZX0ge1xuICAgIHJldHVybiBkZWNvZGU8JHtjbGFzc05hbWV9PihidWYpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVjb2RlKG9iajogSlNPTi5PYmopOiAke2NsYXNzTmFtZX0ge1xuICAgICR7Y3JlYXRlRGVjb2RlU3RhdGVtZW50cyhfY2xhc3MpLmpvaW4oJ1xcbiAgICAnKX0gICAgXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfZW5jb2RlKG5hbWU6IHN0cmluZyB8IG51bGwgPSBcIlwiLCBfZW5jb2RlcjogSlNPTkVuY29kZXIgfCBudWxsID0gbnVsbCk6IEpTT05FbmNvZGVyIHtcbiAgICBsZXQgZW5jb2RlciA9IF9lbmNvZGVyID09IG51bGwgPyBuZXcgSlNPTkVuY29kZXIoKSA6IF9lbmNvZGVyO1xuICAgIGVuY29kZXIucHVzaE9iamVjdChuYW1lKTtcbiAgICAke2NyZWF0ZUVuY29kZVN0YXRlbWVudHMoX2NsYXNzKS5qb2luKCdcXG4gICAgJyl9XG4gICAgZW5jb2Rlci5wb3BPYmplY3QoKTtcbiAgICByZXR1cm4gZW5jb2RlcjtcbiAgfVxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZSgpLnNlcmlhbGl6ZSgpO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZSgpO1xuICB9XG5cbiAgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZSgpLnRvU3RyaW5nKCk7XG4gIH1cbn1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gdG9TdHJpbmcoc3RtdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0pO1xuICAgIHJldHVybiBzb3VyY2VUZXh0LmNvbmNhdCh0aGlzLnNiKS5qb2luKCdcXG4nKTtcbiAgfVxufVxuIl19