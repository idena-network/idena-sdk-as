// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.2.7
//   protoc        v3.12.3

import { Writer, Reader } from "as-proto";

export namespace models {
  export class ProtoStateIdentity {
    static encode(message: ProtoStateIdentity, writer: Writer): void {
      writer.uint32(10);
      writer.bytes(message.stake);

      writer.uint32(16);
      writer.uint32(message.invites);

      writer.uint32(24);
      writer.uint32(message.birthday);

      writer.uint32(32);
      writer.uint32(message.state);

      writer.uint32(40);
      writer.uint32(message.qualifiedFlips);

      writer.uint32(48);
      writer.uint32(message.shortFlipPoints);

      writer.uint32(58);
      writer.bytes(message.pubKey);

      writer.uint32(64);
      writer.uint32(message.requiredFlips);

      const flips = message.flips;
      for (let i = 0; i < flips.length; ++i) {
        writer.uint32(74);
        writer.fork();
        models.ProtoStateIdentity.Flip.encode(flips[i], writer);
        writer.ldelim();
      }

      writer.uint32(80);
      writer.uint32(message.generation);

      writer.uint32(90);
      writer.bytes(message.code);

      const invitees = message.invitees;
      for (let i = 0; i < invitees.length; ++i) {
        writer.uint32(98);
        writer.fork();
        models.ProtoStateIdentity.TxAddr.encode(invitees[i], writer);
        writer.ldelim();
      }

      const inviter = message.inviter;
      if (inviter !== null) {
        writer.uint32(106);
        writer.fork();
        models.ProtoStateIdentity.Inviter.encode(inviter, writer);
        writer.ldelim();
      }

      writer.uint32(114);
      writer.bytes(message.penalty);

      writer.uint32(120);
      writer.uint32(message.validationBits);

      writer.uint32(128);
      writer.uint32(message.validationStatus);

      writer.uint32(138);
      writer.bytes(message.profileHash);

      writer.uint32(146);
      writer.bytes(message.scores);

      writer.uint32(154);
      writer.bytes(message.delegatee);

      writer.uint32(160);
      writer.uint32(message.delegationNonce);

      writer.uint32(168);
      writer.uint32(message.delegationEpoch);

      writer.uint32(176);
      writer.uint32(message.shardId);

      writer.uint32(184);
      writer.bool(message.pendingUndelegation);

      writer.uint32(194);
      writer.bytes(message.replenishedStake);

      writer.uint32(200);
      writer.uint32(message.penaltySeconds);

      writer.uint32(208);
      writer.int64(message.penaltyTimestamp);
    }

    static decode(reader: Reader, length: i32): ProtoStateIdentity {
      const end: usize = length < 0 ? reader.end : reader.ptr + length;
      const message = new ProtoStateIdentity();

      while (reader.ptr < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.stake = reader.bytes();
            break;

          case 2:
            message.invites = reader.uint32();
            break;

          case 3:
            message.birthday = reader.uint32();
            break;

          case 4:
            message.state = reader.uint32();
            break;

          case 5:
            message.qualifiedFlips = reader.uint32();
            break;

          case 6:
            message.shortFlipPoints = reader.uint32();
            break;

          case 7:
            message.pubKey = reader.bytes();
            break;

          case 8:
            message.requiredFlips = reader.uint32();
            break;

          case 9:
            message.flips.push(
              models.ProtoStateIdentity.Flip.decode(reader, reader.uint32())
            );
            break;

          case 10:
            message.generation = reader.uint32();
            break;

          case 11:
            message.code = reader.bytes();
            break;

          case 12:
            message.invitees.push(
              models.ProtoStateIdentity.TxAddr.decode(reader, reader.uint32())
            );
            break;

          case 13:
            message.inviter = models.ProtoStateIdentity.Inviter.decode(
              reader,
              reader.uint32()
            );
            break;

          case 14:
            message.penalty = reader.bytes();
            break;

          case 15:
            message.validationBits = reader.uint32();
            break;

          case 16:
            message.validationStatus = reader.uint32();
            break;

          case 17:
            message.profileHash = reader.bytes();
            break;

          case 18:
            message.scores = reader.bytes();
            break;

          case 19:
            message.delegatee = reader.bytes();
            break;

          case 20:
            message.delegationNonce = reader.uint32();
            break;

          case 21:
            message.delegationEpoch = reader.uint32();
            break;

          case 22:
            message.shardId = reader.uint32();
            break;

          case 23:
            message.pendingUndelegation = reader.bool();
            break;

          case 24:
            message.replenishedStake = reader.bytes();
            break;

          case 25:
            message.penaltySeconds = reader.uint32();
            break;

          case 26:
            message.penaltyTimestamp = reader.int64();
            break;

          default:
            reader.skipType(tag & 7);
            break;
        }
      }

      return message;
    }

    stake: Uint8Array;
    invites: u32;
    birthday: u32;
    state: u32;
    qualifiedFlips: u32;
    shortFlipPoints: u32;
    pubKey: Uint8Array;
    requiredFlips: u32;
    flips: Array<models.ProtoStateIdentity.Flip>;
    generation: u32;
    code: Uint8Array;
    invitees: Array<models.ProtoStateIdentity.TxAddr>;
    inviter: models.ProtoStateIdentity.Inviter | null;
    penalty: Uint8Array;
    validationBits: u32;
    validationStatus: u32;
    profileHash: Uint8Array;
    scores: Uint8Array;
    delegatee: Uint8Array;
    delegationNonce: u32;
    delegationEpoch: u32;
    shardId: u32;
    pendingUndelegation: bool;
    replenishedStake: Uint8Array;
    penaltySeconds: u32;
    penaltyTimestamp: i64;

    constructor(
      stake: Uint8Array = new Uint8Array(0),
      invites: u32 = 0,
      birthday: u32 = 0,
      state: u32 = 0,
      qualifiedFlips: u32 = 0,
      shortFlipPoints: u32 = 0,
      pubKey: Uint8Array = new Uint8Array(0),
      requiredFlips: u32 = 0,
      flips: Array<models.ProtoStateIdentity.Flip> = [],
      generation: u32 = 0,
      code: Uint8Array = new Uint8Array(0),
      invitees: Array<models.ProtoStateIdentity.TxAddr> = [],
      inviter: models.ProtoStateIdentity.Inviter | null = null,
      penalty: Uint8Array = new Uint8Array(0),
      validationBits: u32 = 0,
      validationStatus: u32 = 0,
      profileHash: Uint8Array = new Uint8Array(0),
      scores: Uint8Array = new Uint8Array(0),
      delegatee: Uint8Array = new Uint8Array(0),
      delegationNonce: u32 = 0,
      delegationEpoch: u32 = 0,
      shardId: u32 = 0,
      pendingUndelegation: bool = false,
      replenishedStake: Uint8Array = new Uint8Array(0),
      penaltySeconds: u32 = 0,
      penaltyTimestamp: i64 = 0
    ) {
      this.stake = stake;
      this.invites = invites;
      this.birthday = birthday;
      this.state = state;
      this.qualifiedFlips = qualifiedFlips;
      this.shortFlipPoints = shortFlipPoints;
      this.pubKey = pubKey;
      this.requiredFlips = requiredFlips;
      this.flips = flips;
      this.generation = generation;
      this.code = code;
      this.invitees = invitees;
      this.inviter = inviter;
      this.penalty = penalty;
      this.validationBits = validationBits;
      this.validationStatus = validationStatus;
      this.profileHash = profileHash;
      this.scores = scores;
      this.delegatee = delegatee;
      this.delegationNonce = delegationNonce;
      this.delegationEpoch = delegationEpoch;
      this.shardId = shardId;
      this.pendingUndelegation = pendingUndelegation;
      this.replenishedStake = replenishedStake;
      this.penaltySeconds = penaltySeconds;
      this.penaltyTimestamp = penaltyTimestamp;
    }
  }

  export namespace ProtoStateIdentity {
    export class Flip {
      static encode(message: Flip, writer: Writer): void {
        writer.uint32(10);
        writer.bytes(message.cid);

        writer.uint32(16);
        writer.uint32(message.pair);
      }

      static decode(reader: Reader, length: i32): Flip {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Flip();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cid = reader.bytes();
              break;

            case 2:
              message.pair = reader.uint32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      cid: Uint8Array;
      pair: u32;

      constructor(cid: Uint8Array = new Uint8Array(0), pair: u32 = 0) {
        this.cid = cid;
        this.pair = pair;
      }
    }

    export class TxAddr {
      static encode(message: TxAddr, writer: Writer): void {
        writer.uint32(10);
        writer.bytes(message.hash);

        writer.uint32(18);
        writer.bytes(message.address);
      }

      static decode(reader: Reader, length: i32): TxAddr {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TxAddr();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;

            case 2:
              message.address = reader.bytes();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      hash: Uint8Array;
      address: Uint8Array;

      constructor(
        hash: Uint8Array = new Uint8Array(0),
        address: Uint8Array = new Uint8Array(0)
      ) {
        this.hash = hash;
        this.address = address;
      }
    }

    export class Inviter {
      static encode(message: Inviter, writer: Writer): void {
        writer.uint32(10);
        writer.bytes(message.hash);

        writer.uint32(18);
        writer.bytes(message.address);

        writer.uint32(24);
        writer.uint32(message.epochHeight);
      }

      static decode(reader: Reader, length: i32): Inviter {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Inviter();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;

            case 2:
              message.address = reader.bytes();
              break;

            case 3:
              message.epochHeight = reader.uint32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      hash: Uint8Array;
      address: Uint8Array;
      epochHeight: u32;

      constructor(
        hash: Uint8Array = new Uint8Array(0),
        address: Uint8Array = new Uint8Array(0),
        epochHeight: u32 = 0
      ) {
        this.hash = hash;
        this.address = address;
        this.epochHeight = epochHeight;
      }
    }
  }

  export class ProtoBlockHeader {
    static encode(message: ProtoBlockHeader, writer: Writer): void {
      const proposedHeader = message.proposedHeader;
      if (proposedHeader !== null) {
        writer.uint32(10);
        writer.fork();
        models.ProtoBlockHeader.Proposed.encode(proposedHeader, writer);
        writer.ldelim();
      }

      const emptyHeader = message.emptyHeader;
      if (emptyHeader !== null) {
        writer.uint32(18);
        writer.fork();
        models.ProtoBlockHeader.Empty.encode(emptyHeader, writer);
        writer.ldelim();
      }
    }

    static decode(reader: Reader, length: i32): ProtoBlockHeader {
      const end: usize = length < 0 ? reader.end : reader.ptr + length;
      const message = new ProtoBlockHeader();

      while (reader.ptr < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.proposedHeader = models.ProtoBlockHeader.Proposed.decode(
              reader,
              reader.uint32()
            );
            break;

          case 2:
            message.emptyHeader = models.ProtoBlockHeader.Empty.decode(
              reader,
              reader.uint32()
            );
            break;

          default:
            reader.skipType(tag & 7);
            break;
        }
      }

      return message;
    }

    proposedHeader: models.ProtoBlockHeader.Proposed | null;
    emptyHeader: models.ProtoBlockHeader.Empty | null;

    constructor(
      proposedHeader: models.ProtoBlockHeader.Proposed | null = null,
      emptyHeader: models.ProtoBlockHeader.Empty | null = null
    ) {
      this.proposedHeader = proposedHeader;
      this.emptyHeader = emptyHeader;
    }
  }

  export namespace ProtoBlockHeader {
    export class Proposed {
      static encode(message: Proposed, writer: Writer): void {
        writer.uint32(10);
        writer.bytes(message.parentHash);

        writer.uint32(16);
        writer.uint64(message.height);

        writer.uint32(24);
        writer.int64(message.timestamp);

        writer.uint32(34);
        writer.bytes(message.txHash);

        writer.uint32(42);
        writer.bytes(message.proposerPubKey);

        writer.uint32(50);
        writer.bytes(message.root);

        writer.uint32(58);
        writer.bytes(message.identityRoot);

        writer.uint32(64);
        writer.uint32(message.flags);

        writer.uint32(74);
        writer.bytes(message.ipfsHash);

        writer.uint32(82);
        writer.bytes(message.offlineAddr);

        writer.uint32(90);
        writer.bytes(message.txBloom);

        writer.uint32(98);
        writer.bytes(message.blockSeed);

        writer.uint32(106);
        writer.bytes(message.feePerGas);

        writer.uint32(112);
        writer.uint32(message.upgrade);

        writer.uint32(122);
        writer.bytes(message.seedProof);

        writer.uint32(130);
        writer.bytes(message.receiptsCid);
      }

      static decode(reader: Reader, length: i32): Proposed {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Proposed();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.parentHash = reader.bytes();
              break;

            case 2:
              message.height = reader.uint64();
              break;

            case 3:
              message.timestamp = reader.int64();
              break;

            case 4:
              message.txHash = reader.bytes();
              break;

            case 5:
              message.proposerPubKey = reader.bytes();
              break;

            case 6:
              message.root = reader.bytes();
              break;

            case 7:
              message.identityRoot = reader.bytes();
              break;

            case 8:
              message.flags = reader.uint32();
              break;

            case 9:
              message.ipfsHash = reader.bytes();
              break;

            case 10:
              message.offlineAddr = reader.bytes();
              break;

            case 11:
              message.txBloom = reader.bytes();
              break;

            case 12:
              message.blockSeed = reader.bytes();
              break;

            case 13:
              message.feePerGas = reader.bytes();
              break;

            case 14:
              message.upgrade = reader.uint32();
              break;

            case 15:
              message.seedProof = reader.bytes();
              break;

            case 16:
              message.receiptsCid = reader.bytes();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      parentHash: Uint8Array;
      height: u64;
      timestamp: i64;
      txHash: Uint8Array;
      proposerPubKey: Uint8Array;
      root: Uint8Array;
      identityRoot: Uint8Array;
      flags: u32;
      ipfsHash: Uint8Array;
      offlineAddr: Uint8Array;
      txBloom: Uint8Array;
      blockSeed: Uint8Array;
      feePerGas: Uint8Array;
      upgrade: u32;
      seedProof: Uint8Array;
      receiptsCid: Uint8Array;

      constructor(
        parentHash: Uint8Array = new Uint8Array(0),
        height: u64 = 0,
        timestamp: i64 = 0,
        txHash: Uint8Array = new Uint8Array(0),
        proposerPubKey: Uint8Array = new Uint8Array(0),
        root: Uint8Array = new Uint8Array(0),
        identityRoot: Uint8Array = new Uint8Array(0),
        flags: u32 = 0,
        ipfsHash: Uint8Array = new Uint8Array(0),
        offlineAddr: Uint8Array = new Uint8Array(0),
        txBloom: Uint8Array = new Uint8Array(0),
        blockSeed: Uint8Array = new Uint8Array(0),
        feePerGas: Uint8Array = new Uint8Array(0),
        upgrade: u32 = 0,
        seedProof: Uint8Array = new Uint8Array(0),
        receiptsCid: Uint8Array = new Uint8Array(0)
      ) {
        this.parentHash = parentHash;
        this.height = height;
        this.timestamp = timestamp;
        this.txHash = txHash;
        this.proposerPubKey = proposerPubKey;
        this.root = root;
        this.identityRoot = identityRoot;
        this.flags = flags;
        this.ipfsHash = ipfsHash;
        this.offlineAddr = offlineAddr;
        this.txBloom = txBloom;
        this.blockSeed = blockSeed;
        this.feePerGas = feePerGas;
        this.upgrade = upgrade;
        this.seedProof = seedProof;
        this.receiptsCid = receiptsCid;
      }
    }

    export class Empty {
      static encode(message: Empty, writer: Writer): void {
        writer.uint32(10);
        writer.bytes(message.parentHash);

        writer.uint32(16);
        writer.uint64(message.height);

        writer.uint32(26);
        writer.bytes(message.root);

        writer.uint32(34);
        writer.bytes(message.identityRoot);

        writer.uint32(40);
        writer.int64(message.timestamp);

        writer.uint32(50);
        writer.bytes(message.blockSeed);

        writer.uint32(56);
        writer.uint32(message.flags);
      }

      static decode(reader: Reader, length: i32): Empty {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Empty();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.parentHash = reader.bytes();
              break;

            case 2:
              message.height = reader.uint64();
              break;

            case 3:
              message.root = reader.bytes();
              break;

            case 4:
              message.identityRoot = reader.bytes();
              break;

            case 5:
              message.timestamp = reader.int64();
              break;

            case 6:
              message.blockSeed = reader.bytes();
              break;

            case 7:
              message.flags = reader.uint32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      parentHash: Uint8Array;
      height: u64;
      root: Uint8Array;
      identityRoot: Uint8Array;
      timestamp: i64;
      blockSeed: Uint8Array;
      flags: u32;

      constructor(
        parentHash: Uint8Array = new Uint8Array(0),
        height: u64 = 0,
        root: Uint8Array = new Uint8Array(0),
        identityRoot: Uint8Array = new Uint8Array(0),
        timestamp: i64 = 0,
        blockSeed: Uint8Array = new Uint8Array(0),
        flags: u32 = 0
      ) {
        this.parentHash = parentHash;
        this.height = height;
        this.root = root;
        this.identityRoot = identityRoot;
        this.timestamp = timestamp;
        this.blockSeed = blockSeed;
        this.flags = flags;
      }
    }
  }

  export class ProtoStateGlobal {
    static encode(message: ProtoStateGlobal, writer: Writer): void {
      writer.uint32(8);
      writer.uint32(message.epoch);

      writer.uint32(16);
      writer.int64(message.nextValidationTime);

      writer.uint32(24);
      writer.uint32(message.validationPeriod);

      writer.uint32(34);
      writer.bytes(message.godAddress);

      writer.uint32(42);
      writer.bytes(message.wordsSeed);

      writer.uint32(48);
      writer.uint64(message.lastSnapshot);

      writer.uint32(56);
      writer.uint64(message.epochBlock);

      writer.uint32(66);
      writer.bytes(message.feePerGas);

      writer.uint32(72);
      writer.uint64(message.vrfProposerThreshold);

      writer.uint32(82);
      writer.bytes(message.emptyBlocksBits);

      writer.uint32(88);
      writer.uint32(message.godAddressInvites);

      writer.uint32(96);
      writer.uint32(message.blocksCntWithoutCeremonialTxs);

      const prevEpochBlocks = message.prevEpochBlocks;
      if (prevEpochBlocks.length !== 0) {
        for (let i = 0; i < prevEpochBlocks.length; ++i) {
          writer.uint32(104);
          writer.uint64(prevEpochBlocks[i]);
        }
      }

      writer.uint32(112);
      writer.uint32(message.shardsNum);

      const emptyBlocksByShards = message.emptyBlocksByShards;
      for (let i = 0; i < emptyBlocksByShards.length; ++i) {
        writer.uint32(122);
        writer.fork();
        models.ProtoStateGlobal.EmptyBlocksByShards.encode(
          emptyBlocksByShards[i],
          writer
        );
        writer.ldelim();
      }

      const shardSizes = message.shardSizes;
      for (let i = 0; i < shardSizes.length; ++i) {
        writer.uint32(130);
        writer.fork();
        models.ProtoStateGlobal.ShardSize.encode(shardSizes[i], writer);
        writer.ldelim();
      }
    }

    static decode(reader: Reader, length: i32): ProtoStateGlobal {
      const end: usize = length < 0 ? reader.end : reader.ptr + length;
      const message = new ProtoStateGlobal();

      while (reader.ptr < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            message.epoch = reader.uint32();
            break;

          case 2:
            message.nextValidationTime = reader.int64();
            break;

          case 3:
            message.validationPeriod = reader.uint32();
            break;

          case 4:
            message.godAddress = reader.bytes();
            break;

          case 5:
            message.wordsSeed = reader.bytes();
            break;

          case 6:
            message.lastSnapshot = reader.uint64();
            break;

          case 7:
            message.epochBlock = reader.uint64();
            break;

          case 8:
            message.feePerGas = reader.bytes();
            break;

          case 9:
            message.vrfProposerThreshold = reader.uint64();
            break;

          case 10:
            message.emptyBlocksBits = reader.bytes();
            break;

          case 11:
            message.godAddressInvites = reader.uint32();
            break;

          case 12:
            message.blocksCntWithoutCeremonialTxs = reader.uint32();
            break;

          case 13:
            message.prevEpochBlocks.push(reader.uint64());
            break;

          case 14:
            message.shardsNum = reader.uint32();
            break;

          case 15:
            message.emptyBlocksByShards.push(
              models.ProtoStateGlobal.EmptyBlocksByShards.decode(
                reader,
                reader.uint32()
              )
            );
            break;

          case 16:
            message.shardSizes.push(
              models.ProtoStateGlobal.ShardSize.decode(reader, reader.uint32())
            );
            break;

          default:
            reader.skipType(tag & 7);
            break;
        }
      }

      return message;
    }

    epoch: u32;
    nextValidationTime: i64;
    validationPeriod: u32;
    godAddress: Uint8Array;
    wordsSeed: Uint8Array;
    lastSnapshot: u64;
    epochBlock: u64;
    feePerGas: Uint8Array;
    vrfProposerThreshold: u64;
    emptyBlocksBits: Uint8Array;
    godAddressInvites: u32;
    blocksCntWithoutCeremonialTxs: u32;
    prevEpochBlocks: Array<u64>;
    shardsNum: u32;
    emptyBlocksByShards: Array<models.ProtoStateGlobal.EmptyBlocksByShards>;
    shardSizes: Array<models.ProtoStateGlobal.ShardSize>;

    constructor(
      epoch: u32 = 0,
      nextValidationTime: i64 = 0,
      validationPeriod: u32 = 0,
      godAddress: Uint8Array = new Uint8Array(0),
      wordsSeed: Uint8Array = new Uint8Array(0),
      lastSnapshot: u64 = 0,
      epochBlock: u64 = 0,
      feePerGas: Uint8Array = new Uint8Array(0),
      vrfProposerThreshold: u64 = 0,
      emptyBlocksBits: Uint8Array = new Uint8Array(0),
      godAddressInvites: u32 = 0,
      blocksCntWithoutCeremonialTxs: u32 = 0,
      prevEpochBlocks: Array<u64> = [],
      shardsNum: u32 = 0,
      emptyBlocksByShards: Array<models.ProtoStateGlobal.EmptyBlocksByShards> = [],
      shardSizes: Array<models.ProtoStateGlobal.ShardSize> = []
    ) {
      this.epoch = epoch;
      this.nextValidationTime = nextValidationTime;
      this.validationPeriod = validationPeriod;
      this.godAddress = godAddress;
      this.wordsSeed = wordsSeed;
      this.lastSnapshot = lastSnapshot;
      this.epochBlock = epochBlock;
      this.feePerGas = feePerGas;
      this.vrfProposerThreshold = vrfProposerThreshold;
      this.emptyBlocksBits = emptyBlocksBits;
      this.godAddressInvites = godAddressInvites;
      this.blocksCntWithoutCeremonialTxs = blocksCntWithoutCeremonialTxs;
      this.prevEpochBlocks = prevEpochBlocks;
      this.shardsNum = shardsNum;
      this.emptyBlocksByShards = emptyBlocksByShards;
      this.shardSizes = shardSizes;
    }
  }

  export namespace ProtoStateGlobal {
    export class EmptyBlocksByShards {
      static encode(message: EmptyBlocksByShards, writer: Writer): void {
        writer.uint32(8);
        writer.uint32(message.shardId);

        const proposers = message.proposers;
        if (proposers.length !== 0) {
          for (let i = 0; i < proposers.length; ++i) {
            writer.uint32(18);
            writer.bytes(proposers[i]);
          }
        }
      }

      static decode(reader: Reader, length: i32): EmptyBlocksByShards {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new EmptyBlocksByShards();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.shardId = reader.uint32();
              break;

            case 2:
              message.proposers.push(reader.bytes());
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      shardId: u32;
      proposers: Array<Uint8Array>;

      constructor(shardId: u32 = 0, proposers: Array<Uint8Array> = []) {
        this.shardId = shardId;
        this.proposers = proposers;
      }
    }

    @unmanaged
    export class ShardSize {
      static encode(message: ShardSize, writer: Writer): void {
        writer.uint32(8);
        writer.uint32(message.shardId);

        writer.uint32(16);
        writer.uint32(message.size);
      }

      static decode(reader: Reader, length: i32): ShardSize {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new ShardSize();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.shardId = reader.uint32();
              break;

            case 2:
              message.size = reader.uint32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      shardId: u32;
      size: u32;

      constructor(shardId: u32 = 0, size: u32 = 0) {
        this.shardId = shardId;
        this.size = size;
      }
    }
  }
}
